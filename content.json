{"meta":{"title":"糜家智の博客","subtitle":"","description":"","author":"Mi JiaZhi","url":"https://miren521.gihub.io","root":"/"},"pages":[{"title":"关于我","date":"2021-07-25T08:06:25.171Z","updated":"2021-07-25T08:06:25.171Z","comments":true,"path":"about/index.html","permalink":"https://miren521.gihub.io/about/index.html","excerpt":"","text":"基本信息 糜家智（De-lovely）、男、汉、1998 QQ：2286101414 个人博客：https://miren123.gitee.io 擅长语言：php（thinkphp、laravel） 职业专长：PHP全栈开发、cms端、api接口开发 个人项目 码云：https://gitee.com/miren123 github：https://github.com/miren521 看云：http://kan.lovemi.ren vue电商后台：http://mi.vue.lovemi.ren 商城app：http://mimall.lovemi.ren/download/app.apk 个人简介 我是糜家智，网名迷人，很自恋的这样一个称呼，因为我姓糜（mi）谐音，加上读书时，确实有点自恋，于是朋友们叫我迷人，不要见怪。 角色：php全栈工程师 ——一个95后程序员，终身学习者。 工作：保持对技术的热情，保持谦虚之心，保持学习的动力。——信念和目标，必须永远洋溢在程序员的内心。 专业技能：主职业是前端，后端，擅长php（tp、laravel），vue，uniapp等，运维也有所涉及。 娱乐：爱韩剧，但并非陷入韩剧的空想中；爱旅游，工作完成的业余之际；喜欢英雄联盟，老玩家一枚，中端选手。 心态：爱生活、爱阅读、爱编程、爱学习、爱拼搏、爱家人。 原则：常怀感恩的心。 社交：一个人走得快，一群人走得远。 理财：人生就像滚雪球。最重要之事是发现够湿的雪和长长的山坡。 2019.10——2020.07贵州翌宸志信科技有限公司地点：花果园金融街 岗位：php工程师 工作内容：主要负责php后台（layui、vue-element-admin）、api接口开发 经历：外包公司，app、小程序、官网，网站等定制开发，这个时候还没有毕业，属于应届生，加上疫情原因，能够在3月初找到工作，内心是异常高兴，同时也遇到了非常照顾我的前辈（晓波、刚子），很耐心，非常感激。 同时也有我的前端小伙伴（环子、世贤），刚开始有很大的压力，因为与我一同进入公司的还有一位两年经验的前辈，但是最终我留了下来，庆幸的同时，不禁暗自下定决心，一点得非常，非常用心跟着前辈学习，不然两年后，我找工作同样可能也会被后辈淘汰。 白天在公司写代码，下班后也会抽时间学习新知识，很充实，主要还是前辈们很照顾我，这点很幸福，公司环境很融洽。 可能说，工资方面不是特别的尽人意，但是想着毕竟还没有毕业，能够拥有工作，并且还有这么好的前辈，多学点东西是非常不错的，直到临近毕业（7月中旬），得回校，最终还是离职了，心里很有不舍，融洽的环境，耐心体贴的前辈，有趣的同事，但是工作的目的不就是为了挣钱嘛，男孩子果断一些。 离职的当天，前辈（晓波）给予了很多学习资料，内心甚是感动，十分感谢其照顾。https://edk24.com/ （这是晓波的博客，可以去踩一下。） 一段非常令我难以忘记，同时也让我成长许多的经历，告一段落。 项目经历红鑫羽 一家打造服装服务，日用百货，预包装食品的超市app。 实现了，管理员管理，线上订单，人员管理等功能，整个系统结构清晰，具有较强的可扩展性，有利于后期维护和持久化。 我主要负责后台中，店铺管理，官网管理等多个模块的实现。业务逻辑层的编写，数据库的设计以及对数据库操作的类的编写。 前端接口购物车，从购物车结算商品，个人信息管理等，数据库的设计以及接口实现 学康乐 一家与学校线上教育，周边培训课程，家长孩子论坛与一体的app。 实现了，管理员管理，培训机构权限管理，人员管理等功能，整个系统结构清晰，具有较强的可扩展性，有利于后期维护和持久化。 我主要负责后台中，培训机构，官网管理,培训机构视频上传，多图上传等多个模块的实现。业务逻辑层的编写，数据库的设计以及对数据库操作的类的编写 联系博主"},{"title":"archives","date":"2020-07-09T08:06:49.000Z","updated":"2021-07-10T12:13:04.824Z","comments":true,"path":"archives/index.html","permalink":"https://miren521.gihub.io/archives/index.html","excerpt":"","text":""},{"title":"示例博客","date":"2021-07-10T12:13:04.826Z","updated":"2021-07-10T12:13:04.826Z","comments":true,"path":"friends/index.html","permalink":"https://miren521.gihub.io/friends/index.html","excerpt":"示 例 博 客 这些是一部分使用了「Volantis」主题的博客，由博主自助添加。如果你也使用了「Volantis」，希望在这里推广自己的博客，可以按照本页下方提供的格式自行添加。","text":"示 例 博 客 这些是一部分使用了「Volantis」主题的博客，由博主自助添加。如果你也使用了「Volantis」，希望在这里推广自己的博客，可以按照本页下方提供的格式自行添加。 编辑此页 请点击上方的按钮，在 GitHub 上编辑此页。以友链的格式新增条目。 打开 压缩图 将图片尺寸调整到 192px 后下载。 将压缩后的图片上传到 sm.ms 图床 并使用此图片链接作为头像。 举个栗子1234- name: xaoxuu url: https://xaoxuu.com avatar: https://i.loli.net/2020/04/26/lmJ1xrQ2KR9YZiz.jpg tags: [主题作者] 本站使用了持续集成，在您提交的更改通过审核并合并代码的几分钟后再刷新网页即生效。"},{"title":"所有分类","date":"2021-07-10T12:13:04.825Z","updated":"2021-07-10T12:13:04.825Z","comments":true,"path":"categories/index.html","permalink":"https://miren521.gihub.io/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2021-07-10T12:13:04.899Z","updated":"2021-07-10T12:13:04.899Z","comments":true,"path":"tags/index.html","permalink":"https://miren521.gihub.io/tags/index.html","excerpt":"","text":""},{"title":"留言板","date":"2020-05-20T15:25:38.000Z","updated":"2021-07-10T12:13:04.897Z","comments":true,"path":"msgboard/index.html","permalink":"https://miren521.gihub.io/msgboard/index.html","excerpt":"","text":""}],"posts":[{"title":"uniapp中动态底部导航栏tabbar实现，权限管理","slug":"前端/uni-app/uniapp中动态底部导航栏tabbar实现，权限管理","date":"2022-04-24T12:12:54.000Z","updated":"2022-04-24T14:46:20.286Z","comments":true,"path":"cl2dei665000kw4wf6vjx98l9/","link":"","permalink":"https://miren521.gihub.io/cl2dei665000kw4wf6vjx98l9/","excerpt":"有时候根据业务的需求，需要实现权限，或者是动态底部的导航栏，这是其中一种实现方法，我自己就用。此方法需要借助uView的自定义导航栏","text":"有时候根据业务的需求，需要实现权限，或者是动态底部的导航栏，这是其中一种实现方法，我自己就用。此方法需要借助uView的自定义导航栏 uniapp中动态tabbar实现按照正常的方法引入uView，在需要用到导航栏的页面引入即可。不过page.json里也要正常配置 需要用到的页面 123456789101112131415161718192021222324252627282930313233343536373839&lt;template&gt; &lt;view class&#x3D;&quot;body&quot;&gt; &lt;u-tabbar v-model&#x3D;&quot;current&quot; :before-switch&#x3D;&quot;beforeSwitch&quot; active-color&#x3D;&quot;#1d6869&quot; :list&#x3D;&quot;tabarList&quot;&gt;&lt;&#x2F;u-tabbar&gt; &lt;&#x2F;view&gt;&lt;&#x2F;template&gt;&lt;script&gt; import &#123; mapState, mapMutations &#125; from &quot;vuex&quot;; export default &#123; components: &#123;&#125;, data() &#123; return &#123;&#125;; &#125;, computed: &#123; ...mapState([&quot;tabarList&quot;]), &#125;, onLoad() &#123;&#125;, methods: &#123; ...mapMutations([&quot;setTabarList&quot;]), beforeSwitch(index) &#123; if (this.tabarList[index].text &#x3D;&#x3D; &quot;客服&quot;) &#123; this.kfshow &#x3D; true; return false; &#125; else &#123; return true; &#125; &#125;, &#125; &#125;;&lt;&#x2F;script&gt;&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;&lt;&#x2F;style&gt; 创建目录utils/tabBar.js这是封装权限的目录 123456789101112131415161718192021222324252627282930313233343536373839404142// 个人用户const member = [&#123; iconPath: &quot;home&quot;, selectedIconPath: &quot;home-fill&quot;, text: &#x27;个人首页&#x27;, customIcon: false, pagePath: &#x27;/pages/index/index&#x27;, &#125;, &#123; iconPath: &quot;account&quot;, selectedIconPath: &quot;account-fill&quot;, text: &#x27;我的&#x27;, isDot: false, pagePath: &#x27;/pages/my/my&#x27;, &#125;,]// 企业用户const firm = [ &#123; iconPath: &quot;account&quot;, selectedIconPath: &quot;account-fill&quot;, text: &#x27;企业首页&#x27;, isDot: false, pagePath: &#x27;/pages/enterprise/enterprise&#x27; &#125;, &#123; iconPath: &quot;account&quot;, selectedIconPath: &quot;account-fill&quot;, text: &#x27;我的&#x27;, isDot: false, pagePath: &#x27;/pages/my/my&#x27;, &#125;,]export default &#123; member, firm&#125; 利用vuex，创建目录store/index.js 1234567891011121314151617181920212223242526272829303132333435363738394041import Vue from &#x27;vue&#x27;import Vuex from &#x27;vuex&#x27;import storage from &#x27;../common/storage&#x27;import tabBar from &#x27;@/untils/tabBar.js&#x27;Vue.use(Vuex)// 获取用户的类型，也可以根据业务判断具体的权限let userInfo = storage.getJson(&#x27;userInfo&#x27;)let type = &#x27;member&#x27;if(userInfo != null)&#123; switch(userInfo.utype)&#123; case &#x27;1&#x27;: type = &#x27;member&#x27; break; case &#x27;2&#x27;: type = &#x27;firm&#x27; break; default: break; &#125;&#125;const store = new Vuex.Store(&#123; state: &#123; tabarList: tabBar[type], // 动态底部导航栏 &#125;, mutations: &#123; setTabarList(state, list) &#123; state.tabarList = list &#125;, &#125;, getters: &#123; &#125;, actions: &#123; &#125;&#125;)export default store main.js 配置 12import store from &#x27;./store&#x27;Vue.prototype.$store = store 封装可以全局调用的方法，在需要的地方调用，实时改变底部导航栏 12345678910111213141516171819202122232425262728293031323334353637import storage from &quot;./storage&quot;;import store from &#x27;../store&#x27;import tabBar from &#x27;@/untils/tabBar.js&#x27;export default &#123; set(name, value) &#123; uni.setStorageSync(name, value); &#125;, get(name) &#123; return uni.getStorageSync(name); &#125;, remove(name) &#123; uni.removeStorageSync(name); &#125;, clear() &#123; uni.clearStorageSync(); &#125;, changeList() &#123; let userInfo = storage.getJson(&quot;userInfo&quot;); let type = &quot;member&quot;; if (userInfo != null) &#123; switch (userInfo.utype) &#123; case &quot;1&quot;: type = &quot;member&quot;; break; case &quot;2&quot;: type = &quot;firm&quot;; break; default: break; &#125; &#125; store.state.tabarList = tabBar[type]; &#125;,&#125;; 在登录成功，退出账号，再次登录，或者切换身份等调用 1234567// 只调用一次，避免二次渲染，退出登录，清除this.$storage.clear()let isTabbar = this.$storage.get(&quot;isTabbar&quot;);if (isTabbar == &quot;&quot;) &#123; this.$storage.set(&quot;isTabbar&quot;, 1); this.$storage.changeList()&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://miren521.gihub.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"uni-app","slug":"前端/uni-app","permalink":"https://miren521.gihub.io/categories/%E5%89%8D%E7%AB%AF/uni-app/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://miren521.gihub.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"uni-app","slug":"uni-app","permalink":"https://miren521.gihub.io/tags/uni-app/"},{"name":"页面操作","slug":"页面操作","permalink":"https://miren521.gihub.io/tags/%E9%A1%B5%E9%9D%A2%E6%93%8D%E4%BD%9C/"}]},{"title":"webstorm设置自定义注释","slug":"工具/webstorm设置自定义注释","date":"2022-04-11T05:30:14.000Z","updated":"2022-04-24T14:39:38.816Z","comments":true,"path":"cl2deciay000gw4wf1mz8dgqv/","link":"","permalink":"https://miren521.gihub.io/cl2deciay000gw4wf1mz8dgqv/","excerpt":"webstorm功能的强大，就不多做介绍了。在开发过程中总是需要对代码进行一些个性化的注解，这样方便咱们更加有效率的开发","text":"webstorm功能的强大，就不多做介绍了。在开发过程中总是需要对代码进行一些个性化的注解，这样方便咱们更加有效率的开发 前言 普通的注释 1234/** * * @param values */ 自定义的注释 12345/** * 作者：作者的名字 * 时间：2022/04/18 17:02:59 * 功能： */ 除此之外，还可以加上一些业务上需要的注释。 实现 设置 → 编辑器 → 实时模板 点击右侧的加号，选择动态模板 缩写，就是快捷键的简写，和打印log的时候一样，输入des再回车即可。 在模板文本的下面，有设置使用的文件，大家添加的时候就可以看到。 时间变量的设置 时间变量，需要设置一下，不然数值有点不对。 小结 这是2020之后的版本，官方已经有中文插件了，大家可以在插件市场下载安装 除此之外，还可以定义个性化的注释，也适用于其它的方法注释。","categories":[{"name":"工具","slug":"工具","permalink":"https://miren521.gihub.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"效率开发","slug":"效率开发","permalink":"https://miren521.gihub.io/tags/%E6%95%88%E7%8E%87%E5%BC%80%E5%8F%91/"},{"name":"webstorm","slug":"webstorm","permalink":"https://miren521.gihub.io/tags/webstorm/"}]},{"title":"vscode自定义注释","slug":"工具/vscode自定义注释","date":"2022-04-09T02:03:14.000Z","updated":"2022-04-24T14:32:24.461Z","comments":true,"path":"cl2ddwvuy0000w4wf63ku1r8k/","link":"","permalink":"https://miren521.gihub.io/cl2ddwvuy0000w4wf63ku1r8k/","excerpt":"vscode作为大家日常开发的工具，我就不多说了。注释的重要性，在开发当中可以说是重中之重，而个性化的自定义注释，则是能够大幅度完善我们的项目开发。","text":"vscode作为大家日常开发的工具，我就不多说了。注释的重要性，在开发当中可以说是重中之重，而个性化的自定义注释，则是能够大幅度完善我们的项目开发。 第一步：命令面板 使用ctrl + shift + p 调出如下窗口，并且输入snippets 第二步：json文件编辑 自定义js注释为例 进入到 javascript.json 文件中后，添加如下代码，大家可以自定义设计，保存退出即可，我这里是一个类注释 一个方法注释 随后大家在方法的上面输入des，即可生成自己想要的注释。 prefix 里的内容可以自定义 php、ts、css等都可以 1234567891011121314151617181920&quot;Print to js class&quot;: &#123; &quot;prefix&quot;: &quot;des&quot;, &quot;body&quot;: [ &quot;/*&quot;, &quot; * 作者: 作者&quot;, &quot; * 时间: $&#123;CURRENT_YEAR&#125;-$&#123;CURRENT_MONTH&#125;-$&#123;CURRENT_DATE&#125; $&#123;CURRENT_HOUR&#125;:$&#123;CURRENT_MINUTE&#125;:$&#123;CURRENT_SECOND&#125;&quot;, &quot; * 功能: $0&quot;, &quot; */&quot; ],&#125;,&quot;Print to js method&quot;: &#123; &quot;prefix&quot;: &quot;des&quot;, &quot;body&quot;: [ &quot;/*&quot;, &quot; * 作者: 作者&quot;, &quot; * 时间: $&#123;CURRENT_YEAR&#125;-$&#123;CURRENT_MONTH&#125;-$&#123;CURRENT_DATE&#125; $&#123;CURRENT_HOUR&#125;:$&#123;CURRENT_MINUTE&#125;:$&#123;CURRENT_SECOND&#125;&quot;, &quot; * 功能: $0&quot;, &quot; */&quot; ],&#125;, 补充 不知道是不是我没有找到，还是版本的问题，我没有找到 jsx 的注释，但是在js里面配置又没有生效。我就试着在全局代码片段里设置了一下，生效了，如果大家没有找到 jsx ，或者是需要自己注释的 json 文件，就全局里配置一下即可。 全局代码片段里的内容如下 和 js 的没有区别，把 js 改成了 jsx 1234567891011121314151617181920&quot;Print to jsx class&quot;: &#123; &quot;prefix&quot;: &quot;des&quot;, &quot;body&quot;: [ &quot;/*&quot;, &quot; * 作者: 作者&quot;, &quot; * 时间: $&#123;CURRENT_YEAR&#125;-$&#123;CURRENT_MONTH&#125;-$&#123;CURRENT_DATE&#125; $&#123;CURRENT_HOUR&#125;:$&#123;CURRENT_MINUTE&#125;:$&#123;CURRENT_SECOND&#125;&quot;, &quot; * 功能: $0&quot;, &quot; */&quot; ],&#125;,&quot;Print to jsx method&quot;: &#123; &quot;prefix&quot;: &quot;des&quot;, &quot;body&quot;: [ &quot;/*&quot;, &quot; * 作者: 作者&quot;, &quot; * 时间: $&#123;CURRENT_YEAR&#125;-$&#123;CURRENT_MONTH&#125;-$&#123;CURRENT_DATE&#125; $&#123;CURRENT_HOUR&#125;:$&#123;CURRENT_MINUTE&#125;:$&#123;CURRENT_SECOND&#125;&quot;, &quot; * 功能: $0&quot;, &quot; */&quot; ],&#125;,","categories":[{"name":"工具","slug":"工具","permalink":"https://miren521.gihub.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"vscode","slug":"vscode","permalink":"https://miren521.gihub.io/tags/vscode/"},{"name":"效率开发","slug":"效率开发","permalink":"https://miren521.gihub.io/tags/%E6%95%88%E7%8E%87%E5%BC%80%E5%8F%91/"}]},{"title":"前端指南-面试-js部分","slug":"前端/学习指南/面试/基础/js","date":"2021-08-23T03:20:14.000Z","updated":"2021-12-06T08:19:17.217Z","comments":true,"path":"ckycsfmmh002pm0wfbombcal7/","link":"","permalink":"https://miren521.gihub.io/ckycsfmmh002pm0wfbombcal7/","excerpt":"这是对于前端-js部分的学习笔记及分享，会一直更新，保持学习的进步","text":"这是对于前端-js部分的学习笔记及分享，会一直更新，保持学习的进步","categories":[{"name":"前端","slug":"前端","permalink":"https://miren521.gihub.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"基础","slug":"前端/基础","permalink":"https://miren521.gihub.io/categories/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://miren521.gihub.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://miren521.gihub.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"分享","slug":"分享","permalink":"https://miren521.gihub.io/tags/%E5%88%86%E4%BA%AB/"},{"name":"基础","slug":"基础","permalink":"https://miren521.gihub.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"js","slug":"js","permalink":"https://miren521.gihub.io/tags/js/"}]},{"title":"96道面试题","slug":"前端/学习指南/96道面试题","date":"2021-08-23T03:20:14.000Z","updated":"2021-12-06T08:19:17.212Z","comments":true,"path":"ckycsfmmt003ym0wfh7zk04g8/","link":"","permalink":"https://miren521.gihub.io/ckycsfmmt003ym0wfh7zk04g8/","excerpt":"96道面试题","text":"96道面试题 前端面试题：1. 一些开放性题目1）自我介绍：除了基本个人信息以外，面试官更想听的是你与众不同的地方和你的优势。2）项目介绍 3）如何看待前端开发？ 4）平时是如何学习前端开发的？5）未来三到五年的规划是怎样的？ 2. position的值，relative和absolute分别是相对于谁进行定位的？absolute :生成绝对定位的元素， 相对于最近一级的 定位不是 static 的父元素来进行定位。fixed （老IE不支持）生成绝对定位的元素，通常相对于浏览器窗口或 frame 进行定位。relative 生成相对定位的元素，相对于其在普通流中的位置进行定位。 static 默认值。没有定位，元素出现在正常的流中 sticky 生成粘性定位的元素，容器的位置根据正常文档流计算得出 3. 如何解决跨域问题JSONP原理是：动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。 由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON数据并执行回调函数，从而解决了跨域的数据请求。 优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请求。JSONP：json+padding（内填充），顾名思义，就是把JSON填充到一个盒子里 123456789101112131415functioncreateJs(sUrl)&#123; var oScript = document.createElement(&#x27;script&#x27;); oScript.type = &#x27;text/javascript&#x27;; oScript.src = sUrl; document.getElementsByTagName(&#x27;head&#x27;)[0].appendChild(oScript);&#125;createJs(&#x27;jsonp.js&#x27;);box(&#123; &#x27;name&#x27;: &#x27;test&#x27;&#125;);functionbox(json)&#123; alert(json.name);&#125; CORS服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。 通过修改document.domain来跨子域 将子域和主域的document.domain设为同一个主域.前提条件：这两个域名必须属于同一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行跨域 主域相同的使用document.domain使用window.name来进行跨域 window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的 使用HTML5中新引进的window.postMessage方法来跨域传送数据 还有flash、在服务器上设置代理页面等跨域方式。个人认为window.name的方法既不复杂，也能兼容到几乎所有浏览器，这真是极好的一种跨域方法。 4. XML和JSON的区别？(1).数据体积方面。 JSON相对于XML来讲，数据的体积小，传递的速度更快些。 (2).数据交互方面。 JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。 (3).数据描述方面。 JSON对数据的描述性比XML较差。 (4).传输速度方面。 JSON的速度要远远快于XML。 5. 谈谈你对webpack的看法WebPack 是一个模块打包工具，你可以使用WebPack管理你的模块依赖，并编绎输出模块们所需的静态文件。它能够很好地管理、打包Web开发中所用到的HTML、JavaScript、CSS以及各种静态文件（图片、字体等），让开发过程更加高效。对于不同类型的资源，webpack有对应的模块加载器。webpack模块打包器会分析模块间的依赖关系，最后 生成了优化且合并后的静态资源。 webpack的两大特色： 1）code splitting（可以自动完成） 2）loader 可以处理各种类型的静态文件，并且支持串联操作 webpack 是以commonJS的形式来书写脚本滴，但对 AMD/CMD 的支持也很全面，方便旧项目进行代码迁移。 webpack具有requireJs和browserify的功能，但仍有很多自己的新特性： 1）对 CommonJS 、 AMD、ES6的语法做了兼容 2）对js、css、图片等资源文件都支持打包 3）串联式模块加载器以及插件机制，让其具有更好的灵活性和扩展性，例如提供对CoffeeScript、ES6的支持 4）有独立的配置文件webpack.config.js 5）可以将代码切割成不同的chunk，实现按需加载，降低了初始化时间 6）支持 SourceUrls 和SourceMaps，易于调试 7）具有强大的Plugin接口，大多是内部插件，使用起来比较灵活 8）webpack 使用异步 IO 并具有多级缓存。这使得 webpack 很快且在增量编译上更加快 6. 说说TCP传输的三次握手四次挥手策略为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送出去后，TCP不会对传送 后的情况置之不理，它一定会向对方确认是否成功送达。握手过程中使用了TCP的标志：SYN和ACK。 发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。 最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。 若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。 断开一个TCP连接则需要“四次握手”： 1）第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。 2）第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。 3）第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。 4）第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。 7. TCP和UDP的区别TCP（Transmission Control Protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“对话”才能建立起来 UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！ UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境。 8. 说说你对作用域链的理解作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，变量访问到window对象即被终止，作用域链向下访问变量是不被允许的。 9. 创建ajax过程(1)创建XMLHttpRequest对象,也就是创建一个异步调用对象. (2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息. (3)设置响应HTTP请求状态变化的函数. (4)发送HTTP请求. (5)获取异步调用返回的数据. (6)使用JavaScript和DOM实现局部刷新. 10. 渐进增强和优雅降级渐进增强 ：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。 优雅降级 ：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。 11. 常见web安全及防护原理sql注入原理 就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。 总的来说有以下几点： 1）永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双”-“进行转换等。 2）**永远不要使用动态拼装SQL**，可以使用参数化的SQL或者直接使用存储过程进行数据查询存取。 3）永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。 4）不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息。 12. XSS原理及防范Xss(cross-site scripting)攻击指的是攻击者往Web页面里插入恶意html标签或者javascript代码。 比如：攻击者在论坛中放一个看似安全的链接，骗取用户点击后，窃取cookie中的用户私密信息；或者攻击者在论坛中加一个恶意表单， 当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点。 XSS防范方法 首先代码里对用户输入的地方和变量都需要仔细检查长度和对”&lt;”,”&gt;”,”;”,”’”等字符做过滤；其次任何内容写到页面之前都必须加以encode，避免不小心把html tag 弄出来。这一个层面做好，至少可以堵住超过一半的XSS 攻击。 首先，避免直接在cookie 中泄露用户隐私，例如email、密码等等。 其次，通过使cookie 和系统ip 绑定来降低cookie 泄露后的危险。这样攻击者得到的cookie 没有实际价值，不可能拿来重放。 如果网站不需要再浏览器端对cookie 进行操作，可以在Set-Cookie 末尾加上HttpOnly 来防止javascript代码直接获取cookie 。 尽量采用POST 而非GET 提交表单 13. XSS与CSRF有什么区别吗？ XSS是获取信息，不需要提前知道其他用户页面的代码和数据包。CSRF是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。 要完成一次CSRF攻击，受害者必须依次完成两个步骤：登录受信任网站A，并在本地生成Cookie。 在不登出A的情况下，访问危险网站B。CSRF的防御 服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数。 通过验证码的方法 14. Web Worker和webSocketworker主线程: 1）通过 worker = new Worker( url ) 加载一个JS文件来创建一个worker，同时返回一个worker实例。 2）通过worker.postMessage( data) 方法来向worker发送数据。 3）绑定worker.onmessage方法来接收worker发送过来的数据。 4）可以使用 worker.terminate() 来终止一个worker的执行。 WebSocket是Web应用程序的传输协议，它提供了双向的，按序到达的数据流。他是一个Html5协议，WebSocket的连接是持久的，他通过在客户端和服务器之间保持双工连接，服务器的更新可以被及时推送给客户端，而不需要客户端以一定时间间隔去轮询。 15. HTTP和HTTPSHTTP协议通常承载于TCP协议之上，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的HTTPS。 默认HTTP的端口号为80，HTTPS的端口号为443。为什么HTTPS安全 因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果使用HTTPS，密钥在你和终点站才有。https之所以比http安全，是因为他利用ssl/tls协议传输。它包含证书，卸载，流量转发，负载均衡，页面适配，浏览器适配，refer传递等。保障了传输过程的安全性 16. 对前端模块化的认识AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。AMD 是提前执行，CMD 是延迟执行。 AMD推荐的风格通过返回一个对象做为模块对象，CommonJS的风格通过对module.exports或exports 的属性赋值来达到暴露模块对象的目的。CMD模块方式 define(function(require, exports,module) { // 模块代码}); 17，Javascript垃圾回收方法标记清除（mark and sweep） 这是JavaScript最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”。 垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量（闭包），在这些完成之后仍存在标记的就是要删除的变量了 引用计数(reference counting) 在低版本IE中经常会出现内存泄露，很多时候就是因为其采用引用计数方式进行垃圾回收。引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加1，如果该变量的值变成了另外一个，则这个值得引用次数减1，当这个值的引用次数变为0的时 候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为0的值占用的空间。 在IE中虽然JavaScript对象通过标记清除的方式进行垃圾回收，但BOM与DOM对象却是通过引用计数回收垃圾的， 也就是说只要涉及BOM及DOM就会出现循环引用问题。 18，你觉得前端工程的价值体现在哪为简化用户使用提供技术支持（交互部分）为多个浏览器兼容性提供支持 为提高用户浏览速度（浏览器性能）提供支持 为跨平台或者其他基于webkit或其他渲染引擎的应用提供支持为展示数据提供支持（数据接口） 19，谈谈性能优化问题代码层面：避免使用css表达式，避免使用高级选择器，通配选择器。 缓存利用：缓存Ajax，使用CDN，使用外部js和css文件以便缓存，添加Expires头，服务端配置Etag，减少DNS查找等 请求数量：合并样式和脚本，使用css图片精灵，初始首屏之外的图片资源按需加载，静态资源延迟加载。 请求带宽：压缩文件，开启GZIP，代码层面的优化 用hash-table来优化查找少用全局变量 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能用setTimeout来避免页面失去响应 缓存DOM节点查找的结果避免使用CSS Expression避免全局查询 避免使用with(with会创建自己的作用域，会增加作用域链长度)多个变量声明合并 避免图片和iFrame等的空Src。空Src会重新加载当前页面，影响速度和效率尽量避免写在HTML标签中写Style属性 移动端性能优化 尽量使用css3动画，开启硬件加速。适当使用touch事件代替click事件。避免使用css3渐变阴影效果。 可以用transform: translateZ(0)来开启硬件加速。 不滥用Float。Float在渲染时计算量比较大，尽量减少使用 不滥用Web字体。Web字体需要下载，解析，重绘当前页面，尽量减少使用。合理使用requestAnimationFrame动画代替setTimeout CSS中的属性（CSS3 transitions、CSS3 3D transforms、Opacity、Canvas、WebGL、Video）会触发GPU渲染，请合理使用。过渡使用会引发手机过耗电增加 PC端的在移动端同样适用 20，什么是Etag？当发送一个服务器请求时，浏览器首先会进行缓存过期判断。浏览器根据缓存过期时间判断缓存文件是否过期。 情景一：若没有过期，则不向服务器发送请求，直接使用缓存中的结果，此时我们在浏览器控制台中可以看到 200 OK(from cache) ，此时的情况就是完全使用缓存，浏览器和服务器没有任何交互的。 情景二：若已过期，则向服务器发送请求，此时请求中会带上①中设置的文件修改时间，和Etag 然后，进行资源更新判断。服务器根据浏览器传过来的文件修改时间，判断自浏览器上一次请求之后，文件是不是没有被修改过；根据Etag，判断文件内容自上一次请求之后，有没有发生变化 情形一：若两种判断的结论都是文件没有被修改过，则服务器就不给浏览器发index.html的内容了，直接告诉它，文件没有被修改过，你用你那边的缓存吧—— 304 Not Modified，此时浏览器就会从本地缓存中获取index.html的内容。此时的情况叫协议缓存，浏览器和服务器之间有一次请求交互。 情形二：若修改时间和文件内容判断有任意一个没有通过，则服务器会受理此次请求，之后的操作同① ① 只有get请求会被缓存，post请求不会 21，Expires和Cache-ControlExpires要求客户端和服务端的时钟严格同步。HTTP1.1引入Cache-Control来克服Expires头的限制。如果max-age和Expires同时出现，则max-age有更高的优先级。 Cache-Control:no-cache, private, max-age=0 ETag: abcde Expires: Thu, 15 Apr 201420:00:00 GMT Pragma: private Last-Modified:$now //RFC1123 format 22，Etag应用:Etag由服务器端生成，客户端通过If-Match或者说If-None-Match这个条件判断请求来验证资源是否修改。常见的是使用If-None-Match。请求一个文件的流程可能如下： ====第一次请求=== 1.客户端发起 HTTP GET 请求一个文件； 2.服务器处理请求，返回文件内容和一堆Header，当然包括Etag(例如”2e681a-6-5d044840”)(假设服务器支持Etag生成和已经开启了Etag).状态码200 ====第二次请求=== 客户端发起 HTTP GET 请求一个文件，注意这个时候客户端同时发送一个If-None-Match头，这个头的内容就是第一次请求时服务器返回的Etag：2e681a-6-5d0448402.服务器判断发送过来的Etag和计算出来的Etag匹配，因此If-None-Match为False，不返回200，返回304，客户端继续使用本地缓存；流程很简单，问题是，如果服务器又设置了Cache-Control:max-age和Expires呢，怎么办 答案是同时使用，也就是说在完全匹配If-Modified-Since和If-None-Match即检查完修改时间和Etag之后， 服务器才能返回304.(不要陷入到底使用谁的问题怪圈) 23，为什么使用Etag请求头?Etag 主要为了解决 Last-Modified 无法解决的一些问题。 24，栈和队列的区别?栈的插入和删除操作都是在一端进行的，而队列的操作却是在两端进行的。队列先进先出，栈先进后出。 栈只允许在表尾一端进行插入和删除，而队列只允许在表尾一端进行插入，在表头一端进行删除 25，栈和堆的区别？栈区（stack）： 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。 堆区（heap） ： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收。堆（数据结构）：堆可以被看成是一棵树，如：堆排序； 栈（数据结构）：一种先进后出的数据结构。 26，快速排序的思想并实现一个快排？“快速排序”的思想很简单，整个排序过程只需要三步： （1）在数据集之中，找一个基准点 （2）建立两个数组，分别存储左边和右边的数组 （3）利用递归进行下次比较 &lt;scripttype=”text/javascript”&gt; functionquickSort(arr){ if(arr.length&lt;=1){ return arr;//如果数组只有一个数，就直接返回； } var num = Math.floor(arr.length/2);//找到中间数的索引值，如果是浮点数，则向下取整var numValue =arr.splice(num,1);//找到中间数的值 var left = []; var right = []; for(var i=0;i&lt;arr.length;i++){ if(arr[i]&lt;numValue){ left.push(arr[i]);//基准点的左边的数传到左边数组 } else{ right.push(arr[i]);//基准点的右边的数传到右边数组 } } returnquickSort(left).concat([numValue],quickSort(right));//递归不断重复比较} alert(quickSort([32,45,37,16,2,87]));//弹出“2,16,32,37,45,87” 27，你觉得jQuery或zepto源码有哪些写的好的地方(答案仅供参考) Query源码封装在一个匿名函数的自执行环境中，有助于防止变量的全局污染，然后通过传入window对象参数，可以使window对象作为局部变量使用，好处是当jquery中访问window对象的时候，就不用将作用域链退回到顶层作用域了，从而可以更快的访问window对象。同样，传入undefined参数，可以缩短查找undefined时的作用域链。 (function( window, undefined ) { //用一个函数域包起来，就是所谓的沙箱 //在这里边var定义的变量，属于这个函数域内的局部变量，避免污染全局 //把当前沙箱需要的外部变量通过函数参数引入进来 //只要保证参数对内提供的接口的一致性，你还可以随意替换传进来的这个参数window.jQuery = window.$ = jQuery; })( window ); jquery将一些原型属性和方法封装在了jquery.prototype中，为了缩短名称，又赋值给了jquery.fn，这是很形象的写法。 有一些数组或对象的方法经常能使用到，jQuery将其保存为局部变量以提高访问速度。jquery实现的链式调用可以节约代码，所返回的都是同一个对象，可以提高代码效率。 28，ES6的了解新增模板字符串（为JavaScript提供了简单的字符串插值功能）、箭头函数（操作符左边为输入的参数，而右边则是进行的操作以及返回的值Inputs=&gt;outputs。） for-of（用来遍历数据—例如数组中的值。） arguments对象可被不定参数和默认参数完美代替。 ES6将promise对象纳入规范，提供了原生的Promise对象。 增加了let和const命令，用来声明变量。 增加了块级作用域。let命令实际上就增加了块级作用域。 ES6规定，var命令和function命令声明的全局变量，属于全局对象的属性；let命令、const命令、class命令声明的全局变量，不属于全局对象的属性。 还有就是引入module模块的概念 29，js继承方式及其优缺点原型链继承的缺点 一是字面量重写原型会中断关系，使用引用类型的原型，并且子类型还无法给超类型传递参数。借用构造函数（类式继承） 借用构造函数虽然解决了刚才两种问题，但没有原型，则复用无从谈起。所以我们需要原型链+借用构造函数的模式，这种模式称为组合继承 组合式继承 组合式继承是比较常用的一种继承方法，其背后的思路是 使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又保证每个实例都有它自己的属性。 30，关于Http 2.0你知道多少？HTTP/2引入了“服务端推（server push）”的概念，它允许服务端在客户端需要数据之前就主动地将数据发送到客户端缓存中，从而提高性能。 HTTP/2提供更多的加密支持 HTTP/2使用多路技术，允许多个消息在一个连接上同时交差。 它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的header都只会占用很小比例的带宽。 31，defer和asyncdefer并行加载js文件，会按照页面上script标签的顺序执行 async并行加载js文件，下载完成立即执行，不会按照页面上script标签的顺序执行 32，谈谈浮动和清除浮动浮动的框可以向左或向右移动，直到他的外边缘碰到包含框或另一个浮动框的边框为止。由于浮动框不在文档的普通流中，所以文档的普通流的块框表现得就像浮动框不存在一样。浮动的块框会漂浮在文档普通流的块框上。 33，如何评价AngularJS和BackboneJSbackbone具有依赖性，依赖underscore.js。Backbone + Underscore + jQuery(or zepto) 就比一个AngularJS多出了2 次HTTP请求. Backbone的Model没有与UI视图数据绑定，而是需要在View中自行操作DOM来更新或读取UI数据。AngularJS与此相反，Model直接与UI视图绑定，Model与UI视图的关系，通过directive封装，AngularJS内置的通用directive，就能实现大部分操作了，也就是说，基本不必关心Model与UI视图的关系，直接操作Model就行了，UI视图自动更新。 AngularJS的directive，你输入特定数据，他就能输出相应UI视图。是一个比较完善的前端MVW框架，包含模板，数据双向绑定，路由，模块化，服务，依赖注入等所有功能，模板功能强大丰富，并且是声明式的，自带了丰富的 Angular 指令。 34，用过哪些设计模式？工厂模式：主要好处就是可以消除对象间的耦合，通过使用工程方法而不是new关键字。将所有实例化的代码集中在一个位置防止代码重复。 工厂模式解决了重复实例化的问题 ，但还有一个问题,那就是识别问题，因为根本无法搞清楚他们到底是哪个对象的实例。 function createObject(name,age,profession){//集中实例化的函数var obj = newObject(); obj.name =name; obj.age = age; obj.profession= profession; obj.move =function () { returnthis.name + ‘ at ‘ + this.age + ‘ engaged in ‘ + this.profession; }; return obj; } var test1 = createObject(‘trigkit4’,22,’programmer’);//第一个实例var test2 =createObject(‘mike’,25,’engineer’);//第二个实例 构造函数模式使用构造函数的方法 ，即解决了重复实例化的问题 ，又解决了对象识别的问题，该模式与工厂模式的不同之处在于： 1）构造函数方法没有显示的创建对象 (new Object()); 2）直接将属性和方法赋值给 this 对象; 3）没有 renturn 语句。 35，说说你对闭包的理解使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念 闭包有三个特性： 1）函数嵌套函数 2）函数内部可以引用外部的参数和变量 3）参数和变量不会被垃圾回收机制回收 36，请你谈谈Cookie的弊端cookie虽然在持久保存客户端数据提供了方便，分担了服务器存储的负担，但还是有很多局限性的。第一：每个特定的域名下最多生成20个cookie 1）IE6或更低版本最多20个cookie 2）IE7和之后的版本最后可以有50个cookie。 3）Firefox最多50个cookie 4）chrome和Safari没有做硬性限制 IE和Opera会清理近期最少使用的cookie，Firefox会随机清理cookie。cookie的最大大约为4096字节，为了兼容性，一般不能超过4095字节。 IE 提供了一种存储可以持久化用户数据，叫做userdata，从IE5.0就开始支持。每个数据最多128K，每个域名下最多1M。这个持久化数据放在缓存中，如果缓存没有清理，那么会一直存在。 优点： 极高的扩展性和可用性 1）通过良好的编程，控制保存在cookie中的session对象的大小。 2）通过加密和安全传输技术（SSL），减少cookie被破解的可能性。 3）只在cookie中存放不敏感数据，即使被盗也不会有重大损失。 4）控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。 缺点： 1） Cookie 数量和长度的限制。每个domain最多只能有20条cookie，每个cookie长度不能超过4KB，否则会被截掉. 2）安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目的了。 3）有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。 37，浏览器本地存储在较高版本的浏览器中，js提供了sessionStorage和globalStorage。在HTML5中提供了localStorage来取代globalStorage。 html5中的Web Storage包括了两种存储方式：sessionStorage和localStorage。 sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。 而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。 38，web storage和cookie的区别Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用。 除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie。 但是cookie也是不可以或缺的：cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生 浏览器的支持除了IE7及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器里运行)，值得一提的是IE总是办好事，例如IE7、IE6中的userData其实就是javascript本地存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持web storage。 localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和removeItem等 39，cookie和session的区别：1）cookie数据存放在客户的浏览器上，session数据放在服务器上。 2）cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗考虑到安全应当使用session。 3）session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用COOKIE。 4）单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。5）所以个人建议： 将登陆信息等重要信息存放为SESSION 其他信息如果需要保留，可以放在COOKIE中 40，display:none和visibility:hidden的区别？display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就当他从来不存在。 visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。 41，CSS中link和@import的区别是？(1) link属于HTML标签，而@import是CSS提供的; (2) 页面被加载的时，link会同时被加载，而@import被引用的CSS会等到引用它的CSS文件被加载完再加载; (3) import只在IE5以上才能识别，而link是HTML标签，无兼容问题; (4) link方式的样式的权重 高于@import的权重. 42，position:absolute和float属性的异同共同点：对内联元素设置float和absolute属性，可以让元素脱离文档流，并且可以设置其宽高。不同点：float仍会占据位置，absolute会覆盖文档流中的其他元素。 43，介绍一下box-sizing属性？box-sizing属性主要用来控制元素的盒模型的解析模式。默认值是content-box。 content-box：让元素维持W3C的标准盒模型。元素的宽度/高度由border + padding + content的宽度/高度决定，设置width/height属性指的是content部分的宽/高 border-box：让元素维持IE传统盒模型（IE6以下版本和IE6~7的怪异模式）。设置width/height属性指的是border + padding + content 标准浏览器下，按照W3C规范对盒模型解析，一旦修改了元素的边框或内距，就会影响元素的盒子尺寸，就不得不重新计算元素的盒子尺寸，从而影响整个页面的布局。 44，选择符有哪些？哪些属性可以继承？1）id选择器（#myid） 2）类选择器（.myclassname） 3）标签选择器（div, h1, p） 4）相邻选择器（h1 + p） 5）子选择器（ul &gt; li） 6）后代选择器（lia） 7）通配符选择器（ * ） 8）属性选择器（a[rel = “external”]） 9）伪类选择器（a: hover, li:nth-child） 45，优先级算法如何计算？优先级为: !important &gt; id &gt; class &gt; tag important 比 内联优先级高,但内联比 id 要高 46，CSS3新增伪类有那些？CSS3新增伪类举例： p:first-of-type选择属于其父元素的首个 元素的每个 元素。p:last-of-type 选择属于其父元素的最后 元素的每个 元素。p:only-of-type 选择属于其父元素唯一的 元素的每个 元素。p:only-child 选择属于其父元素的唯一子元素的每个 元素。 p:nth-child(2) 选择属于其父元素的第二个子元素的每个 元素。:enabled :disabled控制表单控件的禁用状态。 :checked 单选框或复选框被选中。 47，CSS3有哪些新特性？CSS3实现圆角（border-radius），阴影（box-shadow）， 对文字加特效（text-shadow、），线性渐变（gradient），旋转（transform）transform:rotate(9deg) scale(0.85,0.90)translate(0px,-30px) skew(-9deg,0deg);//旋转,缩放,定位,倾斜增加了更多的CSS选择器 多背景 rgba 在CSS3中唯一引入的伪元素是::selection.媒体查询，多栏布局 border-image CSS3中新增了一种盒模型计算方式：box-sizing。盒模型默认的值是content-box, 新增的值是padding- box和border-box，几种盒模型计算元素宽高的区别如下： content-box（默认）布局所占宽度Width： Width = width + padding-left + padding-right + border-left + border-right 布局所占高度Height: Height = height + padding-top + padding-bottom + border-top + border-bottom padding-box 布局所占宽度Width： Width = width(包含padding-left + padding-right) + border-top + border-bottom 布局所占高度Height: Height = height(包含padding-top + padding-bottom) + border-top + border-bottom border-box 布局所占宽度Width： Width = width(包含padding-left + padding-right + border-left + border-right) 布局所占高度Height: Height = height(包含padding-top + padding-bottom + border-top + border-bottom) 48，对BFC规范的理解？BFC，块级格式化上下文，一个创建了新的BFC的盒子是独立布局的，盒子里面的子元素的样式不会影响到外面的元素。在同一个BFC中的两个毗邻的块级盒在垂直方向（和布局方向有关系）的margin会发生折叠。 （W3C CSS 2.1 规范中的一个概念，它决定了元素如何对其内容进行布局，以及与其他元素的关系和相互作用。 49，说说你对语义化的理解？1）去掉或者丢失样式的时候能够让页面呈现出清晰的结构 2）有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重； 3）方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页； 4）便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。 50，Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?1） &lt;!DOCTYPE&gt; 声明位于文档中的最前面，处于 标签之前。告知浏览器以何种模式来渲染文档。 2）严格模式的排版和 JS 运作模式是 以该浏览器支持的最高标准运行。 3）在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。4）DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现。 51，你知道多少种Doctype文档类型？该标签可声明三种DTD类型，分别表示严格版本、过渡版本以及基于框架的 HTML 文档。HTML 4.01 规定了三种文档类型：Strict、Transitional 以及 Frameset。 XHTML 1.0 规定了三种 XML 文档类型：Strict、Transitional 以及 Frameset。 Standards （标准）模式（也就是严格呈现模式）用于呈现遵循最新标准的网页，而 Quirks （包容）模式（也就是松散呈现模式或者兼容模式）用于呈现为传统浏览器而设计的网页。 52，HTML与XHTML——二者有什么区别区别： 1）所有的标记都必须要有一个相应的结束标记 2）所有标签的元素和属性的名字都必须使用小写 3）所有的XML标记都必须合理嵌套 4）所有的属性必须用引号””括起来 5）把所有&lt;和&amp;特殊符号用编码表示 6）给所有属性赋一个值 7）不要在注释内容中使“–” 8）图片必须有说明文字 53，常见兼容性问题？png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8.也可以引用一段脚本处理. 浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一。IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。 浮动ie产生的双倍距离（IE6双边距问题：在IE6下，如果对元素设置了浮动，同时又设置了margin-left或margin-right，margin值会加倍。） #box{ float:left; width:10px; margin:0 0 0 100px;} 这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入 _display:inline; 将其转化为行内属性。(_这个符号只有ie6会识别) 渐进识别的方式，从总体中逐渐排除局部。 首先，巧妙的使用“\\9”这一标记，将IE游览器从所有情况中分离出来。接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。 css 1234567891011.bb&#123;background-color:#f1ee18;&#x2F;*所有识别*&#x2F;.background-color:#00deff\\9; &#x2F;*IE6、7、8识别*&#x2F;+background-color:#a200ff;&#x2F;*IE6、7识别*&#x2F;_background-color:#1e0bd1;&#x2F;*IE6识别*&#x2F;&#125; 怪异模式问题：漏写DTD声明，Firefox仍然会按照标准模式来解析网页，但在IE中会触发 怪异模式。为避免怪异模式给我们带来不必要的麻烦，最好养成书写DTD声明的好习惯。现在可以使用html5推荐的写法： 上下margin重合问题 ie和ff都存在，相邻的两个div的margin-left和margin-right不会重合，但是margin-top和margin- bottom却会发生重合。 解决方法，养成良好的代码编写习惯，同时采用margin-top或者同时采用margin-bottom。 54，解释下浮动和它的工作原理？清除浮动的技巧浮动元素脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留。 1）使用空标签清除浮动。 这种方法是在所有浮动标签后面添加一个空标签 定义cssclear:both. 弊端就是增加了无意义标签。 2）使用overflow。 给包含浮动元素的父标签添加css属性 overflow:auto; zoom:1; zoom:1用于兼容IE6。 3）使用after伪对象清除浮动。 该方法只适用于非IE浏览器。具体写法可参照以下示例。使用中需注意以下几点。一、该方法中必须为需要清除浮动元素的伪对象中设置 height:0，否则该元素会比实际高出若干像素； 55，浮动元素引起的问题和解决办法？浮动元素引起的问题： （1）父元素的高度无法被撑开，影响与父元素同级的元素 （2）与浮动元素同级的非浮动元素（内联元素）会跟随其后 （3）若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构解决方法： 使用CSS中的clear:both;属性来清除元素的浮动可解决2、3问题，对于问题1，添加如下样式，给父元素添加clearfix样式： .clearfix:after{content:”.”;display: block;height:0;clear: both;visibility: hidden;} .clearfix{display: inline-block;} /* for IE/Mac */ 56，清除浮动的几种方法：1）额外标签法， &lt;divstyle=”clear:both;”&gt; （缺点：不过这个办法会增加额外的标签使HTML结构看起来不够简洁。） 2）使用after伪类 #parent:after{ content:”.”; height:0; visibility:hidden; display:block; clear:both; } 3）浮动外部元素 4）设置overflow为hidden或者auto 57，DOM操作——怎样添加、移除、移动、复制、创建和查找节点。1）创建新节点 createDocumentFragment() //创建一个DOM片段createElement() //创建一个具体的元素createTextNode() //创建一个文本节点 2）添加、移除、替换、插入 appendChild() removeChild() replaceChild() insertBefore() //并没有insertAfter() 3）查找 getElementsByTagName() //通过标签名称 getElementsByName() //通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的) getElementById() //通过元素Id，唯一性 58，html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。拖拽释放(Drag and drop) API 语义化更好的内容标签（header,nav,footer,aside,article,section）音频、视频API(audio,video) 画布(Canvas) API 地理(Geolocation) API 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；sessionStorage 的数据在浏览器关闭后自动删除 表单控件，calendar、date、time、email、url、search新的技术webworker, websocket,Geolocation 移除的元素: 纯表现的元素：basefont，big，center，font, s，strike，tt，u；对可用性产生负面影响的元素：frame，frameset，noframes； 支持HTML5新标签： IE8/IE7/IE6支持通过document.createElement方法产生的标签，可以利用这一特性让这些浏览器支持HTML5新标签， 当然最好的方式是直接使用成熟的框架、使用最多的是html5shim框架 如何区分： DOCTYPE声明\\新增的结构元素\\功能元素 59，如何实现浏览器内多个标签页之间的通信?调用localstorge、cookies等本地存储方式 60，什么是 FOUC（无样式内容闪烁）？你如何来避免 FOUC？FOUC - FlashOf Unstyled Content 文档样式闪烁 1&lt;style type&#x3D;&quot;text&#x2F;css&quot;media&#x3D;&quot;all&quot;&gt;@import&quot;..&#x2F;FOUC.css&quot;;&lt;&#x2F;style&gt; 而引用CSS文件的@import就是造成这个问题的罪魁祸首。IE会先加载整个HTML文档的DOM，然后再去导入外部的CSS文件，因此，在页面DOM加载完成到CSS导入完成中间会有一段时间页面上的内容是没有样式的，这段时间的长短跟网速，电脑速度都有关系。 解决方法简单的出奇，只要在 &lt;head&gt; 之间加入一个 &lt;link&gt; 或者 &lt;script&gt; 元素就可以了。 61，null和undefined的区别null是一个表示”无”的对象，转为数值时为0；undefined是一个表示”无”的原始值，转为数值时为NaN。当声明的变量还未被初始化时，变量的默认值为undefined。 null用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象。undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义。典型用法是： （1）变量被声明了，但没有赋值时，就等于undefined。 （2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。（3）对象没有赋值的属性，该属性的值为undefined。 （4）函数没有返回值时，默认返回undefined。 null表示”没有对象”，即该处不应该有值。典型用法是：（1） 作为函数的参数，表示该函数的参数不是对象。（2） 作为对象原型链的终点。 62，new操作符具体干了什么呢?1）创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。 2）属性和方法被加入到 this 引用的对象中。 3）新创建的对象由 this 所引用，并且最后隐式的返回 this 。 var obj = {}; obj.proto = Base.prototype; Base.call(obj); 63，js延迟加载的方式有哪些？defer和async、动态创建DOM方式（创建script，插入到DOM中，加载完毕后callBack）、按需异步载入js 64，call()和 apply() 的区别和作用？作用：动态改变某个类的某个方法的运行环境（执行上下文）。 65，哪些操作会造成内存泄漏？内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。 垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。 setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。 闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环） 66，列举IE与其他浏览器不一样的特性？IE支持currentStyle，FIrefox使用getComputStyle IE 使用innerText，Firefox使用textContent 滤镜方面：IE:filter:alpha(opacity= num)；Firefox：-moz-opacity:num事件方面：IE：attachEvent：火狐是addEventListener 鼠标位置：IE是event.clientX；火狐是event.pageX IE使用event.srcElement；Firefox使用event.target IE中消除list的原点仅需margin:0即可达到最终效果；FIrefox需要设置margin:0;padding:0以及list- style:none CSS圆角：ie7以下不支持圆角 67，WEB应用从服务器主动推送Data到客户端有那些方式？Javascript数据推送 Commet：基于HTTP长连接的服务器推送技术基于WebSocket的推送方案 SSE（Server-Send Event）：服务器推送数据新方式 68，对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近。 1）实现界面交互 2）提升用户体验 3）有了Node.js，前端可以实现服务端的一些事情 前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好，参与项目，快速高质量完成实现效果图，精确到1px； 与团队成员，UI设计，产品经理的沟通；做好的页面结构，页面重构和用户体验；处理hack，兼容、写出优美的代码格式；针对服务器的优化、拥抱最新前端技术。 69，一个页面从输入 URL到页面加载显示完成，这个过程中都发生了什么？分为4个步骤： （1），当发送一个URL请求时，不管这个URL是Web页面的URL还是Web页面上每个资源的URL，浏览器都会开启一个线程来处理这个请求，同时在远程DNS服务器上启动一个DNS查询。这能使浏览器获得请求对应的IP地址。 （2）， 浏览器与远程 Web 服务器通过 TCP 三次握手协商来建立一个 TCP/IP 连接。该握手包括一个同步报文，一个同步-应答报文和一个应答报文，这三个报文在浏览器和服务器之间传递。该握手首先由客户端尝试建立起通信，而后服务器应答并接受客户端的请求，最后由客户端发出该请求已经被接受的报文。 （3），一旦 TCP/IP 连接建立，浏览器会通过该连接向远程服务器发送 HTTP 的 GET 请求。远程服务器找到资源并使用HTTP响应返回该资源，值为200的HTTP响应状态表示一个正确的响应。 （4），此时， Web 服务器提供资源服务，客户端开始下载资源。请求返回后，便进入了我们关注的前端模块 简单来说，浏览器会解析 HTML 生成 DOM Tree ，其次会根据CSS生成CSS Rule Tree，而 javascript 又可以根据 DOM API 操作 DOM 70，javascript对象的几种创建方式1）工厂模式 2）构造函数模式 3）原型模式 4）混合构造函数和原型模式 5）动态原型模式 6）寄生构造函数模式 7）稳妥构造函数模式 71，javascript继承的6种方法1）原型链继承 2）借用构造函数继承 3）组合继承(原型+借用构造) 4）原型式继承 5）寄生式继承 6）寄生组合式继承 72，创建ajax的过程(1)创建 XMLHttpRequest 对象,也就是创建一个异步调用对象. (2)创建一个新的 HTTP 请求,并指定该 HTTP 请求的方法、 URL 及验证信息. (3)设置响应 HTTP 请求状态变化的函数. (4)发送 HTTP 请求. (5)获取异步调用返回的数据. (6)使用JavaScript和DOM实现局部刷新. var xmlHttp = new XMLHttpRequest(); xmlHttp.open(‘GET’,’demo.php’,’true’); xmlHttp.send() xmlHttp.onreadystatechange = function(){ if(xmlHttp.readyState === 4 &amp; xmlHttp.status=== 200){ } } 73，异步加载和延迟加载1）异步加载的方案： 动态插入script标签 2）通过ajax去获取js代码，然后通过eval执行 3）script标签上添加defer或者async属性 4）创建并插入iframe，让它异步执行js 5）延迟加载：有些 js 代码并不是页面初始化的时候就立刻需要的，而稍后的某些情况才需要的。 74，ie各版本和chrome可以并行下载多少个资源IE6 两个并发，iE7升级之后的6个并发，之后版本也是6个Firefox，chrome也是6个 75，Flash、Ajax各自的优缺点，在使用中如何取舍？Flash适合处理多媒体、矢量图形、访问机器；对CSS、处理文本上不足，不容易被搜索。Ajax对CSS、文本支持很好，支持搜索；多媒体、矢量图形、机器访问不足。 共同点：与服务器的无刷新传递消息、用户离线和在线状态、操作DOM 76，请解释一下 JavaScript的同源策略。概念:同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。 这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。 指一段脚本只能读取来自同一来源的窗口和文档的属性。 77，为什么要有同源限制？我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过Javascript读取到你的表单中input中的内容，这样用户名，密码就轻松到手了。 缺点： 现在网站的JS 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严格模式的文件，被 merge 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在压缩后浪费了字节。 78，GET和POST的区别，何时使用POST？GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符POST：一般用于修改服务器上的资源，对所发送的信息没有限制。 GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值， 也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。然而，在以下情况中，请使用 POST 请求： 无法使用缓存文件（更新服务器上的文件或数据库）向服务器发送大量数据（POST 没有数据量限制） 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠 79，事件、IE\\与火狐的事件机制有什么区别？ 如何阻止冒泡？1）我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为。 2）事件处理机制：IE是事件冒泡、firefox同时支持两种事件模型，也就是：捕获型事件和冒泡型事件。； 3） ev.stopPropagation() ;注意旧ie的方法 ev.cancelBubble = true ; 80，ajax的缺点和在IE下的问题？ajax的缺点 1）ajax不支持浏览器back按钮。 2）安全问题 AJAX暴露了与服务器交互的细节。 3）对搜索引擎的支持比较弱。 4）破坏了程序的异常机制。5）不容易调试。 IE缓存问题 在IE浏览器下，如果请求的方法是GET，并且请求的URL不变，那么这个请求的结果就会被缓存。解决这个问题的办法可以通过实时改变请求的URL，只要URL改变，就不会被缓存，可以通过在URL末尾添加上随机的时间戳参数(‘t’= + newDate().getTime()) 或者： open(‘GET’,’demo.php?rand=+Math.random()’,true);// Ajax请求的页面历史记录状态问题 可以通过锚点来记录状态，location.hash。让浏览器记录Ajax请求时页面状态的变化。还可以通过HTML5的history.pushState，来实现浏览器地址栏的无刷新改变 81，谈谈你对重构的理解网站重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。也就是说是在不改变UI的情况下，对网站进行优化， 在扩展的同时保持一致的UI。 对于传统的网站来说重构通常是：表格(table)布局改为DIV+CSS 使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的)对于移动平台的优化 针对于SEO进行优化 深层次的网站重构应该考虑的方面减少代码间的耦合 让代码保持弹性 严格按规范编写代码设计可扩展的API 代替旧有的框架、语言(如VB)增强用户体验 通常来说对于速度的优化也包含在重构中 压缩JS、CSS、image等前端资源(通常是由服务器来解决)程序的性能优化(如数据读写) 采用CDN来加速资源加载对于JS DOM的优化HTTP服务器的文件缓存 82，HTTP状态码100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息 200 OK 正常返回信息 201 Created 请求成功并且服务器创建了新的资源 202 Accepted 服务器已接受请求，但尚未处理 301 Moved Permanently 请求的网页已永久移动到新位置。 302 Found 临时性重定向。 303 SeeOther 临时性重定向，且总是使用 GET 请求新的 URI。 304 Not Modified 自从上次请求后，请求的网页未修改过。 400 BadRequest 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。 401 Unauthorized 请求未授权。403Forbidden 禁止访问。 404 NotFound 找不到如何与 URI 相匹配的资源。500 InternalServer Error 最常见的服务器端错误。 503 ServiceUnavailable 服务器端暂时无法处理请求（可能是过载或维护）。 83，说说你对Promise的理解依照Promise/A+的定义，Promise 有四种状态：pending: 初始状态, 非fulfilled 或 rejected. fulfilled: 成功的操作. rejected: 失败的操作. settled: Promise已被fulfilled或rejected，且不是pending 另外， fulfilled 与 rejected 一起合称 settled。 Promise 对象用来进行延迟(deferred) 和异步(asynchronous ) 计算。Promise 的构造函数 构造一个 Promise，最基本的用法如下： var promise = new Promise(function(resolve, reject) { if (…) { // succeed resolve(result); } else { // fails reject(Error(errMessage)); } }); Promise 实例拥有 then 方法（具有 then 方法的对象，通常被称为 thenable）。它的使用方法如下： promise.then(onFulfilled, onRejected) 接收两个函数作为参数，一个在 fulfilled 的时候被调用，一个在 rejected 的时候被调用，接收参数就是future，onFulfilled对应 resolve, onRejected 对应 reject。 84，说说你对前端架构师的理解负责前端团队的管理及与其他团队的协调工作，提升团队成员能力和整体效率；带领团队完成研发工具及平台前端部分的设计、研发和维护； 带领团队进行前端领域前沿技术研究及新技术调研，保证团队的技术领先 负责前端开发规范制定、功能模块化设计、公共组件搭建等工作，并组织培训。 实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制 Object.prototype.clone = function(){ var o = this.constructor === Array ? [] : {}; for(var e inthis){ o[e] = typeofthis[e] === “object” ? this[e].clone() : this[e]; } return o; } 85，说说严格模式的限制严格模式主要有以下限制：变量必须声明后再使用 函数的参数不能有同名属性，否则报错不能使用with语句 不能对只读属性赋值，否则报错 不能使用前缀0表示八进制数，否则报错不能删除不可删除的属性，否则报错 不能删除变量delete prop，会报错，只能删除属性delete global[prop] eval不会在它的外层作用域引入变量eval和arguments不能被重新赋值arguments不会自动反映函数参数的变化不能使用arguments.callee 不能使用arguments.caller禁止this指向全局对象 不能使用fn.caller和fn.arguments获取函数调用的堆栈 增加了保留字（比如protected、static和interface） 设立”严格模式”的目的，主要有以下几个： 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;消除代码运行的一些不安全之处，保证代码运行的安全； 提高编译器效率，增加运行速度； 为未来新版本的Javascript做好铺垫。注：经过测试均不支持严格模式。 86，如何删除一个cookie1）将时间设为当前时间往前一点。var date = newDate(); date.setDate(date.getDate() - 1);//真正的删除setDate()方法用于设置一个月的某一天。 2）expires的设置 document.cookie= ‘user=’+ encodeURIComponent(‘name’) + ‘;expires = ‘ + newDate(0) ， 和 ， 标签 标签和 标签一样，用于强调文本，但它强调的程度更强一些。 em 是 斜体强调标签，更强烈强调，表示内容的强调点。相当于html元素中的 … ; &lt; b &gt; &lt; i &gt; 是视觉要素，分别表示无意义的加粗，无意义的斜体。em 和 strong 是表达要素(phraseelements)。 87，说说你对AMD和CommonJS的理解CommonJS是服务器端模块的规范，Node.js采用了这个规范。CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数。 AMD推荐的风格通过返回一个对象做为模块对象，CommonJS的风格通过对module.exports或exports 的属性赋值来达到暴露模块对象的目的。 88，document.write()的用法document.write()方法可以用在两个方面：页面载入过程中用实时脚本创建页面内容，以及用延时脚本创建本窗口或新窗口的内容。 document.write只能重绘整个页面。innerHTML可以重绘页面的一部分编写一个方法求一个字符串的字节长度 假设：一个英文字符占用一个字节，一个中文字符占用两个字节 functionGetBytes(str){ var len = str.length; var bytes = len; for(var i=0; i&lt;len; i++){ if (str.charCodeAt(i) &gt;255) bytes++; } return bytes; } alert(GetBytes(“你好,as”)); 89，git fetch和git pull的区别git pull：相当于是从远程获取最新版本并merge到本地 git fetch：相当于是从远程获取最新版本到本地，不会自动merge 90，说说你对MVC和MVVM的理解MVC View 传送指令到 Controller Controller 完成业务逻辑后，要求 Model 改变状态Model 将新的数据发送到 View，用户得到反馈 所有通信都是单向的。 Angular它采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然。组成部分Model、View、ViewModel View：UI界面 ViewModel：它是View的抽象，负责View与Model之间信息转换，将View的Command传送到Model； Model：数据访问层 91，请解释什么是事件代理事件代理（Event Delegation），又称之为事件委托。是 JavaScript 中常用绑定事件的常用技巧。顾名思义，“事件代理”即是把原本需要绑定的事件委托给父元素，让父元素担当事件监听的职务。事件代理的原理是DOM元素的事件冒泡。使用事件代理的好处是可以提高性能。 92，attribute和property的区别是什么？attribute是DOM元素在文档中作为html标签拥有的属性； property就是DOM元素在js中作为对象拥有的属性。 所以： 对于html的标准属性来说，attribute和property是同步的，是会自动更新的，但是对于自定义的属性来说，他们是不同步的， 93，说说网络分层里七层模型是哪七层应用层：应用层、表示层、会话层（从上往下）（HTTP、FTP、SMTP、DNS）传输层（TCP和UDP） 网络层（IP） 物理和数据链路层（以太网） 每一层的作用如下： 物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）数据链路层：将比特组装成帧和点到点的传递（帧Frame） 网络层：负责数据包从源到宿的传递和网际互连（包PackeT）传输层：提供端到端的可靠报文传递和错误恢复（段Segment）会话层：建立、管理和终止会话（会话协议数据单元SPDU） 表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）应用层：允许访问OSI环境的手段（应用协议数据单元APDU） 各种协议 ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。 TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。 HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。 DHCP协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置参数手段。 94，说说mongoDB和MySQL的区别MySQL是传统的关系型数据库，MongoDB则是非关系型数据库 mongodb以BSON结构（二进制）进行存储，对海量数据存储有着很明显的优势。 对比传统关系型数据库,NoSQL有着非常显著的性能和扩展性优势，与关系型数据库相比，MongoDB的优点有： ①弱一致性（最终一致），更能保证用户的访问速度：②文档结构的存储方式，能够更便捷的获取数据。 95，讲讲304缓存的原理服务器首先产生Etag，服务器可在稍后使用它来判断页面是否已经被修改。本质上，客户端通过将该记号传回服务器要求服务器验证其（客户端）缓存。 304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状态码后，会使用浏览器已缓存的文件 客户端请求一个页面（A）。 服务器返回页面A，并在给A加上一个Etag。 客户端展现该页面，并将页 面连同Etag一起缓存。 客户再次请求页面A，并将上次请求时服务器返回的Etag一起传递给服务器。 服务器检查该Etag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应304（未修改—— Not Modified）和一个空的响应体。 96，什么样的前端代码是好的高复用低耦合，这样文件小，好维护，而且好扩展。","categories":[{"name":"前端","slug":"前端","permalink":"https://miren521.gihub.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"面试","slug":"前端/面试","permalink":"https://miren521.gihub.io/categories/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://miren521.gihub.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://miren521.gihub.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"js","slug":"js","permalink":"https://miren521.gihub.io/tags/js/"}]},{"title":"古怪学习笔记","slug":"前端/学习指南/古怪/古怪学习笔记","date":"2021-07-27T10:29:14.000Z","updated":"2021-12-06T08:19:17.214Z","comments":true,"path":"ckycsfmmn0039m0wf9wmpg5ya/","link":"","permalink":"https://miren521.gihub.io/ckycsfmmn0039m0wf9wmpg5ya/","excerpt":"古怪学习笔记，亲测可用，对于项目开发，提示任务进度，可以提高代码的复用率，笔记中都有比较详细的注释。","text":"古怪学习笔记，亲测可用，对于项目开发，提示任务进度，可以提高代码的复用率，笔记中都有比较详细的注释。 数据展示数据表格展示tp中 h5 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&#123;$Think.config.title&#125;&lt;/title&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,user-scalable=0,initial-scale=1&quot;&gt; &lt;meta name=&quot;format-detection&quot; content=&quot;telephone=yes&quot;/&gt; &lt;script type=&quot;text/javascript&quot;&gt; document.getElementsByTagName(&#x27;html&#x27;)[0].style.fontSize = (document.documentElement.getBoundingClientRect().width || window.screen.width) / 20 + &#x27;px&#x27; window.onresize = function () &#123; document.getElementsByTagName(&#x27;html&#x27;)[0].style.fontSize = (document.documentElement.getBoundingClientRect().width || window.screen.width) / 20 + &#x27;px&#x27; &#125; &lt;/script&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://www.layuicdn.com/layui-v2.5.6/css/layui.css&quot;/&gt;&lt;/head&gt;&lt;body class=&quot;container&quot;&gt;&lt;table class=&quot;layui-table&quot; id=&quot;list&quot; lay-filter=&quot;list&quot;&gt;&lt;/table&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;__static__/js/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/layui/2.6.8/layui.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; layui.use([&#x27;table&#x27;], function () &#123; var $ = layui.jquery, table = layui.table; tableIn = table.render(&#123; elem: &#x27;#list&#x27;, url: &#x27;&#123;:url(&quot;show&quot;)&#125;&#x27;, method: &#x27;post&#x27;, title: &#x27;数据表&#x27;, toolbar: &#x27;#toolbar&#x27;, //开启头部工具栏，并为其绑定左侧模板 // defaultToolbar: [&#x27;filter&#x27;, &#x27;exports&#x27;, &#x27;print&#x27;, &#123; //自定义头部工具栏右侧图标。如无需自定义，去除该参数即可 // title: &#x27;提示&#x27; // ,layEvent: &#x27;LAYTABLE_TIPS&#x27; // ,icon: &#x27;layui-icon-tips&#x27; &#125;], defaultToolbar: false, cols: [[ // &#123;checkbox: true, fixed: true&#125;, &#123;field: &#x27;id&#x27;, title: &#x27;ID&#x27;, width: 80, type: &#x27;numbers&#x27;, fixed: true, sort: true&#125;, &#123;field: &#x27;username&#x27;, title: &#x27;名字&#x27;, width: 150,&#125;, &#123;field: &#x27;wxname&#x27;, title: &#x27;微信名&#x27;, width: 150,&#125;, &#123;field: &#x27;tel&#x27;, title: &#x27;电话&#x27;, width: 150,&#125;, &#123;field: &#x27;score&#x27;, title: &#x27;雪球&#x27;, width: 150,&#125;, // &#123;field: &#x27;create_time&#x27;, title: &#x27;创建时间&#x27;, width: 180,templet:&#x27;#create_time&#x27;&#125;, ]], limits: [5, 10, 15, 20, 25, 50, 100], limit: 15, page: true &#125;); &#125;)&lt;/script&gt;&lt;/html&gt; php 123456789101112131415161718192021222324252627/** * 展示数据表 * 作者：糜家智 * 时间：2021/7/13 10:20 */public function show(Request $request)&#123; if ($request-&gt;isPost()) &#123; $keys = $this-&gt;request-&gt;post(&#x27;keys&#x27;, &#x27;&#x27;, &#x27;trim&#x27;); $where = []; if ($keys != &#x27;&#x27;) &#123; $where[] = [&#x27;title&#x27;, &#x27;like&#x27;, &#x27;%&#x27; . $keys . &#x27;%&#x27;]; &#125; $page = $this-&gt;request-&gt;post(&#x27;page&#x27;); $limit = $this-&gt;request-&gt;post(&#x27;limit&#x27;); $tol = ($page - 1) * $limit; $banner = model(&#x27;user&#x27;)-&gt;where($where)-&gt;limit($tol, $limit) -&gt;order(&#x27;score desc&#x27;) -&gt;select(); $count = model(&#x27;user&#x27;)-&gt;where($where)-&gt;count(); if (!$banner) error(); success($banner, $count); &#125; return view();&#125; 原生php1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;报名名单&lt;/title&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,user-scalable=0,initial-scale=1&quot;&gt; &lt;meta name=&quot;format-detection&quot; content=&quot;telephone=yes&quot;/&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://www.layuicdn.com/layui-v2.5.6/css/layui.css&quot;/&gt; &lt;style&gt; .layui-laypage-skip&#123;display: block !important;&#125; .layui-table-page&#123;height: 118px !important;text-align: center !important;&#125; #list&#123;margin-top: -18px;&#125; .title&#123;position: absolute;width: 100%;top: 4vw;z-index: 999;text-align: center&#125; &lt;/style&gt;&lt;/head&gt;&lt;body class=&quot;container&quot;&gt;&lt;p class=&quot;title&quot;&gt;报名名单&lt;/p&gt;&lt;table class=&quot;layui-table&quot; id=&quot;list&quot; lay-filter=&quot;list&quot;&gt;&lt;/table&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;./js/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/layui/2.6.8/layui.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; layui.use([&#x27;table&#x27;], function () &#123; var $ = layui.jquery, table = layui.table; tableIn = table.render(&#123; elem: &#x27;#list&#x27;, url: &#x27;select.php&#x27;, method: &#x27;post&#x27;, title: &#x27;数据表&#x27;, toolbar: &#x27;#toolbar&#x27;, //开启头部工具栏，并为其绑定左侧模板 defaultToolbar: false, cols: [[ &#123;field: &#x27;0&#x27;, title: &#x27;ID&#x27;, type: &#x27;numbers&#x27;, fixed: true&#125;, &#123;field: &#x27;2&#x27;, title: &#x27;微信名&#x27;, width: 100,&#125;, &#123;field: &#x27;3&#x27;, title: &#x27;名字&#x27;, width: 100,&#125;, &#123;field: &#x27;4&#x27;, title: &#x27;电话&#x27;, width: 120,&#125;, &#123;field: &#x27;5&#x27;, title: &#x27;地址&#x27;, width: 150,&#125;, &#123;field: &#x27;7&#x27;, title: &#x27;身份证号&#x27;, width: 100,&#125;, ]], limits: [5, 10, 15, 20, 25, 50, 100], limit: 10, page: true &#125;); &#125;)&lt;/script&gt;&lt;/html&gt; 查询数据的select.php 1234567891011121314151617181920212223&lt;?phpheader(&#x27;Content-type:text/json&#x27;);require_once(&#x27;php/mysql.class.php&#x27;);$db = new Mysql( array(&#x27;dbhost&#x27; =&gt; &#x27;124.71.68.151&#x27;, &#x27;dbuser&#x27; =&gt; &#x27;guguan&#x27;,//用户名 &#x27;dbpsw&#x27; =&gt; &#x27;guguan2021.&#x27;,//数据库密码 &#x27;dbname&#x27; =&gt; &#x27;guguan&#x27;,//数据库名字 &#x27;dbcharset&#x27; =&gt; &#x27;utf8mb4&#x27;//字符集 ));$table = &#x27;ty_20210709_user&#x27;;$page = $_POST[&#x27;page&#x27;];$limit = $_POST[&#x27;limit&#x27;];$tol = ($page - 1) * $limit;if ($_SERVER[&#x27;REQUEST_METHOD&#x27;] == &#x27;POST&#x27;) &#123; $find = $db-&gt;findAll(&quot;select * from $table limit $tol,$limit&quot;); $count = $db-&gt;findOne(&#x27;select count(id) from &#x27;.$table); echo json_encode([&quot;code&quot; =&gt; 0, &quot;data&quot; =&gt; $find, &quot;count&quot; =&gt; $count[0]]); exit();&#125;?&gt; 排行榜展示 简单模拟，效果没问题 引入js：&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/iScroll/5.2.0/iscroll-infinite.min.js&quot; defer&gt;&lt;/script&gt; ajax初次加载123456789101112131415scrollData = function () &#123; var myScroll = new IScroll(&quot;#wrapper&quot;, &#123; scrollbars: false,//有滚动条 mouseWheel: false,//允许滑轮滚动 interactiveScrollbars: true,//滚动条可以拖动 scrollY: true,//纵向滚动条可以使用 freeScroll: true,//既有上下又有左右（自由滚动） probeType: 1,//对性能没有影响。在滚动事件被触发时，滚动轴是不是忙着做它的东西。 &#125;); //开始滚动时触发的事件 myScroll.on(&quot;scrollStart&quot;, function () &#123; rankData() &#125;);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657rankData = function () &#123; loading = weui.loading(&#x27;loading...&#x27;); $.ajax(&#123; type: &quot;POST&quot;, url: actionRoot + &#x27;get_rank&#x27;, dataType: &#x27;json&#x27;, data: &#123; page: page &#125;, //请求成功 success: function (res) &#123; if (res.code == 1) &#123; var data = res.data; var limit = (page - 1) * 10; for (var i = 0; i &lt; data.length; i++) &#123; var value = i + limit + 1; var num = value; if (value === 1)&#123; num = &#x27;&lt;img class=&quot;rank-img&quot; src=&quot;&#x27;+sources_root+&#x27;img/rank1.png&quot;&gt;&#x27;; &#125; if (value === 2)&#123; num = &#x27;&lt;img class=&quot;rank-img&quot; src=&quot;&#x27;+sources_root+&#x27;img/rank2.png&quot;&gt;&#x27;; &#125; if (value === 3)&#123; num = &#x27;&lt;img class=&quot;rank-img&quot; src=&quot;&#x27;+sources_root+&#x27;img/rank3.png&quot;&gt;&#x27;; &#125; $(`&lt;div class=&quot;rank-c&quot;&gt; &lt;div class=&quot;rank-one&quot;&gt;$&#123;num&#125;&lt;/div&gt; &lt;div&gt;&lt;img class=&quot;rank-head&quot; src=&quot;$&#123;data[i].wxhead&#125;&quot;&gt;&lt;/div&gt; &lt;div class=&quot;wx-name&quot;&gt;$&#123;data[i].wxname&#125;&lt;/div&gt; &lt;div class=&quot;grade&quot;&gt;$&#123;data[i].score&#125;&lt;/div&gt; &lt;/div&gt;`).appendTo($(&quot;#wrapper&quot;)) &#125; loading.hide(); $(&quot;.ranking&quot;).show() page++; &#125; else &#123; mui.toast(res.msg, &#123;duration: &#x27;1000&#x27;, type: &#x27;div&#x27;&#125;) &#125; &#125;, //请求失败，包含具体的错误信息 error: function (e) &#123; console.log(e); &#125; &#125;);&#125; 123456$(&quot;.pageh0-4-2&quot;).click(function() &#123; rankData() setTimeout(function () &#123; scrollData() &#125;, 1000)&#125;) ajax二次加载123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051var myScroll = new IScroll(&quot;#wrapper&quot;, &#123; scrollbars: false,//有滚动条 mouseWheel: false,//允许滑轮滚动 interactiveScrollbars: true,//滚动条可以拖动 scrollY: true,//纵向滚动条可以使用 freeScroll: true,//既有上下又有左右（自由滚动） probeType: 1,//对性能没有影响。在滚动事件被触发时，滚动轴是不是忙着做它的东西。&#125;);var page = 2;//开始滚动时触发的事件myScroll.on(&quot;scrollStart&quot;, function () &#123; loading = weui.loading(&#x27;loading...&#x27;); $.ajax(&#123; type: &quot;POST&quot;, url: actionRoot + &#x27;get_rank&#x27;, dataType: &#x27;json&#x27;, data: &#123; page: page &#125;, //请求成功 success: function (res) &#123; if (res.code == 1) &#123; var data = res.data; var limit = (page - 1) * 10; for (var i = 0; i &lt; data.length; i++) &#123; $(`&lt;div class=&quot;rank-c&quot;&gt; &lt;div class=&quot;rank-one&quot;&gt;$&#123;i + limit + 1&#125;&lt;/div&gt; &lt;div&gt;&lt;img class=&quot;rank-head&quot; src=&quot;$&#123;data[i].wxhead&#125;&quot;&gt;&lt;/div&gt; &lt;div class=&quot;wx-name&quot;&gt;$&#123;data[i].wxname&#125;&lt;/div&gt; &lt;div&gt;$&#123;data[i].score&#125;&lt;/div&gt; &lt;/div&gt;`).appendTo($(&quot;#wrapper&quot;)) &#125; loading.hide(); page++; &#125; else &#123; mui.toast(res.msg, &#123;duration: &#x27;1000&#x27;, type: &#x27;div&#x27;&#125;) &#125; &#125;, //请求失败，包含具体的错误信息 error: function (e) &#123; console.log(e); &#125; &#125;);&#125;); 页面和样式1234567891011121314151617181920212223242526&lt;div class=&quot;ranking&quot; style=&quot;display: none&quot;&gt; &lt;div class=&quot;close&quot;&gt; &lt;/div&gt; &lt;img data-src=&quot;__static__/img/rank.png&quot; class=&quot;rankimg&quot;&gt; &lt;div class=&quot;rank-table&quot; id=&quot;wrapper&quot;&gt; &#123;volist name=&quot;rank&quot; id=&quot;vo&quot; key=&quot;k&quot;&#125; &lt;div class=&quot;rank-c&quot;&gt; &#123;if condition=&quot;$k eq 1&quot;&#125; &lt;div class=&quot;rank-one&quot;&gt;&lt;img class=&quot;rank-img&quot; data-src=&quot;__static__/img/rank1.png&quot;&gt;&lt;/div&gt; &#123;elseif condition=&quot;$k eq 2&quot;&#125; &lt;div class=&quot;rank-one&quot;&gt;&lt;img class=&quot;rank-img&quot; data-src=&quot;__static__/img/rank2.png&quot;&gt;&lt;/div&gt; &#123;elseif condition=&quot;$k eq 3&quot;&#125; &lt;div class=&quot;rank-one&quot;&gt;&lt;img class=&quot;rank-img&quot; data-src=&quot;__static__/img/rank3.png&quot;&gt;&lt;/div&gt; &#123;else/&#125; &lt;div class=&quot;rank-one&quot;&gt;&#123;$k&#125;&lt;/div&gt; &#123;/if&#125; &lt;div&gt;&lt;img class=&quot;rank-head&quot; data-src=&quot;&#123;$vo.wxhead&#125;&quot;&gt;&lt;/div&gt; &lt;div class=&quot;wx-name&quot;&gt;&#123;$vo.wxname&#125;&lt;/div&gt; &lt;div&gt;&#123;$vo.score&#125;&lt;/div&gt; &lt;/div&gt; &#123;/volist&#125; &lt;/div&gt;&lt;/div&gt; 123456789101112.ranking&#123;position: absolute;width: 100%;height: 100%;background-color: rgba(0,0,0,0.7);&#125;.rankimg&#123;width: 80vw;position: absolute;left: 50%;top: 50%;transform: translate(-50%, -50%);&#125;.close&#123;position: absolute;width: 5vw;height: 5vw;left: 50%;top: 50%;transform: translate(-710%, -1172%);&#125;.rank-table&#123; font-size: 12px;width: 65vw;position: absolute;left: 50%;top: 50%;height: 102vw;overflow: hidden; overflow-y: scroll;transform: translate(-50%, -47%);display: flex;flex-direction: column;justify-items: center;&#125;.rank-c&#123;margin-top: 2vw;display: flex;flex-direction: row;justify-items: center;align-items: center;justify-content: space-around;&#125;.wx-name&#123;width: 30%;white-space: nowrap;overflow: hidden;text-overflow: ellipsis;&#125;.rank-head&#123;width: 9vw;height: 9vw;border-radius: 100%;position: sticky !important;&#125;.rank-img&#123;width: 4vw;margin-left: -1vw;margin-top: -1vw;&#125;.rank-one&#123;width: 4vw;height: 4vw;text-align: left&#125; 图片资源 页面显示分享弹窗1234&lt;div class=&quot;share&quot; style=&quot;display: none;position:absolute;height: 100%;width: 100%;background-color: rgba(0,0,0,0.6)&quot;&gt; &lt;img style=&quot;width: 94%;left: 3%&quot; data-src=&quot;__static__/img/share_alert.png&quot; class=&quot;&quot; a-eff=&quot;bounceInUp&quot; a-fun=&quot;&quot; a-dur=&quot;1s&quot; a-del=&quot;1s&quot;/&gt;&lt;/div&gt; 123$(&quot;.share&quot;).click(function () &#123; $(&quot;.share&quot;).hide()&#125;) 助力分享助力 引入js 1&lt;script type=&quot;text/javascript&quot; src=&quot;__static__/js/wxshares.js?v=2&quot; defer&gt;&lt;/script&gt; main.js 123456789101112131415161718192021222324252627getCount = function(type, isCom, callback) &#123; return false; if (!isCom) &#123; isCom = null &#125; if (!type) &#123; type = null &#125; loading = weui.loading(&#x27;loading...&#x27;); $.ajax(&#123; type: &#x27;POST&#x27;, async: false, data: &#123; &#x27;type&#x27;: type, &#x27;isCom&#x27;: isCom &#125;, url: actionRoot + &#x27;getDrawcount&#x27;, success: function(res) &#123; console.log(res.msg) loading.hide(); if (res.code == 1) &#123; weui.alert(&#x27;恭喜您获得一次额外游戏机会！&#x27;) &#125; &#125; &#125;)&#125; wxshares.js 中找到对应方法 数据提交用户信息提交 适用于弹窗为一整张图片，输入框、关闭和提交按钮覆盖图片 12345678910111213&lt;!-- 填写用户信息 --&gt;&lt;div class=&quot;info popover&quot;&gt; &lt;div class=&quot;info-con&quot;&gt; &lt;div class=&quot;close-info&quot;&gt;&lt;/div&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; &lt;input style=&quot;margin-top: 19.8vw&quot; type=&quot;number&quot; name=&quot;tel&quot;&gt; &lt;img data-src=&quot;__static__/img/info-bg.png&quot; btn=&quot;&quot; class=&quot;info-bg ani&quot; a-eff=&quot;zoomIn&quot; a-fun=&quot;&quot; a-dur=&quot;1s&quot; a-del=&quot;0.5s&quot;/&gt; &lt;div class=&quot;sub-info&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819.info-con&#123; position: absolute;left: 50%;top: 35%;width: 100%;height: auto; transform: translate(-50%, -50%);&#125;.info-bg&#123;width: 80%;left: 10%;&#125;input&#123; border: 0;margin-left: 54%;transform: translate(-50%,0); width: 32%;margin-top: 8.7vw;position: absolute;z-index: 999; height: 5vw;background-color: transparent; padding-left: 2vw;&#125;.close-info&#123; position: absolute;left: 83%;top: 2vw;transform: translate(-50%, 0); width: 4vw;height: 4vw;z-index: 999;&#125;.sub-info&#123; position: absolute;left: 50%;top: 33vw;transform: translate(-50%, 0); width: 27vw;height: 10vw;z-index: 999;&#125; 关闭弹窗 123$(&quot;.close-info&quot;).click(function () &#123; $(&quot;.info&quot;).hide()&#125;) 提交信息 1234567891011121314151617181920212223242526//提交信息$(&quot;.sub-info&quot;).click(function() &#123; let name = $(&quot;input[name=&#x27;username&#x27;]&quot;).val(); let tel = $(&quot;input[name=&#x27;tel&#x27;]&quot;).val(); if (name == &quot;&quot; || tel == &quot;&quot;) &#123; return weui.alert(&quot;请填写完整信息&quot;) &#125; if (!checkMobile(tel)) &#123; return weui.alert(&quot;请填写正确的手机号&quot;); &#125; loading = weui.loading(&quot;loading...&quot;); $.post( actionRoot + &quot;putinfo&quot;, &#123; username: name, tel: tel, &#125;, function(res) &#123; loading.hide(); if (res.code == 1) &#123; weui.alert(&quot;信息提交成功！&quot;); &#125; else &#123; weui.alert(res.msg); &#125; $(&quot;.info&quot;).hide(); &#125;, &quot;json&quot;);&#125;) 12345678910111213141516171819202122232425262728293031/** * 提交信息 * 作者：糜家智 * 时间：2021/7/21 15:20 */public function putInfo(Request $request)&#123; $find = model(&#x27;User&#x27;)-&gt;where(&#x27;openid&#x27;, $this-&gt;openid)-&gt;find(); if (!$find) $this-&gt;error(&#x27;网络错误&#x27;); if ($find[&#x27;tel&#x27;]) &#123; $this-&gt;success(&#x27;已经提交过了，无需重复！&#x27;); &#125; $username = $request-&gt;post(&#x27;username&#x27;); $tel = $request-&gt;post(&#x27;tel&#x27;); $insert_data = [ &#x27;username&#x27; =&gt; $username, &#x27;tel&#x27; =&gt; $tel, ]; $res = model(&#x27;User&#x27;)-&gt;where(&#x27;openid&#x27;, $this-&gt;openid)-&gt;update($insert_data); if ($res) &#123; return [&#x27;code&#x27; =&gt; 1, &#x27;msg&#x27; =&gt; &#x27;信息提交成功！&#x27;, &#x27;data&#x27; =&gt; [&#x27;wxname&#x27; =&gt; $this-&gt;wxname, &#x27;openid&#x27; =&gt; $this-&gt;openid, &#x27;wxhead&#x27; =&gt; $this-&gt;wxhead]]; &#125; else &#123; $this-&gt;error(&#x27;网络错误，请稍后再试&#x27;); &#125;&#125; 12345678function checkMobile(str) &#123; var myreg = /^[1][3,4,5,7,8,9][0-9]&#123;9&#125;$/; if (!myreg.test(str)) &#123; return false; &#125; else &#123; return true; &#125;&#125; weui下拉选择1234567891011121314151617var dataArr = [ &#123; label: &#x27;&#x27;, value: &#x27;&#x27; &#125;];$(&quot;.address&quot;).click(function () &#123; weui.picker(dataArr, &#123; defaultValue: &#x27;&#x27;, // 这里是value onChange: function (result) &#123; &#125;, onConfirm: function (result) &#123; $(&quot;input[name=&#x27;address&#x27;]&quot;).val(result[0].value) &#125;, id: &#x27;search_xqpicker&#x27; &#125;);&#125;);","categories":[{"name":"前端","slug":"前端","permalink":"https://miren521.gihub.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"古怪","slug":"前端/古怪","permalink":"https://miren521.gihub.io/categories/%E5%89%8D%E7%AB%AF/%E5%8F%A4%E6%80%AA/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://miren521.gihub.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"开发","slug":"开发","permalink":"https://miren521.gihub.io/tags/%E5%BC%80%E5%8F%91/"},{"name":"javascript","slug":"javascript","permalink":"https://miren521.gihub.io/tags/javascript/"},{"name":"古怪学习","slug":"古怪学习","permalink":"https://miren521.gihub.io/tags/%E5%8F%A4%E6%80%AA%E5%AD%A6%E4%B9%A0/"}]},{"title":"程序员多款软件推荐分享","slug":"生活/必备软件","date":"2021-07-25T07:03:14.000Z","updated":"2021-07-25T07:54:07.439Z","comments":true,"path":"ckycsfmll0007m0wf8oiy6lw6/","link":"","permalink":"https://miren521.gihub.io/ckycsfmll0007m0wf8oiy6lw6/","excerpt":"工欲善其事，必先利其器。对于程序员来说需要的“器”太多了，如今各种同类型的软件都有很多种，但是否都是“利器”呢，等你一个一个装好去试简直就是麻烦。这里直接给还在寻找“利器”的程序员推荐几款必备的辅助软件工具。","text":"工欲善其事，必先利其器。对于程序员来说需要的“器”太多了，如今各种同类型的软件都有很多种，但是否都是“利器”呢，等你一个一个装好去试简直就是麻烦。这里直接给还在寻找“利器”的程序员推荐几款必备的辅助软件工具。 Snipaste 截图+贴图工具官方主页：https://zh.snipaste.com/介绍：Snipaste 是一个简单但强大的截图工具，也可以让你将截图贴回到屏幕上！贴图功能非常好用，尤其是对于单屏显示的程序猿们，再也不用按Alt+Tab来回切换屏幕了 （偷偷告诉你：用Snipaste 辅助写博客也非常方便哦！：） 价格：免费 Notepad++官方主页：https://notepad-plus-plus.org/介绍：Notepad++用来查看源码文件极其方便，用它你就可以不用打开那庞大的工程而直接查看文件的代码。相比使用记事本查看，Notepad++有代码高亮显示，非常适合查看部分工程源码。 价格：免费 Everything官方主页：https://www.voidtools.com/zh-cn/介绍：快速查找电脑中的文件（非常快），相比Window自带的文件检索框，Everything就是降维打击，简直神器！ flux屏幕色温调节 介绍：调节屏幕色温，缓解眼部疲劳，对于天天盯着惨白电脑的人着实是个小福利。官网地址：https://justgetflux.com/价格：免费 福析阅读器官网地址：https://www.foxitsoftware.cn/介绍：做软硬件开发的，总是少不了要看一些官方等等的说明文档以及一些pdf格式的原理图，用自带的浏览器看原理图时总是不好移动，而福析阅读器就能很好的胜任这份工作，并且也可以调节为暗色模式哦 (￣▽￣)ブ价格：普通功能免费，高级功能收费，对于普通用户来说，免费的就够用了 BeyondCompare 代码差异对比工具官网地址：https://www.scootersoftware.com/介绍：使用BeyondCompare您可以快速轻松地比较文件和文件夹。通过使用简单，功能强大的命令，您可以专注于您感兴趣的差异，而忽略那些您不需要的差异。然后，您可以合并更改，同步文件并生成报告以作记录。你可以不使用，但你一定要知道。有时候看学习视频时，对比着人家提供的工程文件，和自己敲的代码和人家的代码明明“一毛一样”，但是自己的就是报错，而你又找不出来，编译器还定位不到错误位置。光靠眼睛去看还不得累死，这时候，导入这两份文件，一个对比，哪里不同清清楚楚，要多爽有多爽。 价格：收费 坚果云官网地址：https://www.jianguoyun.com/ 介绍：实现多设备之间文件同步共享，适合多台电脑办公的，时时工程同步文件到另一台电脑（设备），下班后打开工程就可以继续快乐的干活了，下载速度看个人网速，杠杠的，再也不要5k的速度了。♪(∇*) 价格：普通用户每月最多可上传1GB文件，下载3GB文件。（上传一点工程文件对俺来说还是够用的） WOX你可以将 Wox 看作一个高效的本地快速搜索框，通过快捷键呼出，然后输入关键字来搜索程序进行快速启动，或者搜索本地硬盘的文件，打开百度、Google 进行搜索，甚至是通过一些插件的功能实现单词翻译、关闭屏幕、查询剪贴板历史、查询编程文档、查询天气等更多功能。官网下载地址：http://www.wox.one/","categories":[{"name":"生活","slug":"生活","permalink":"https://miren521.gihub.io/categories/%E7%94%9F%E6%B4%BB/"},{"name":"必备软件","slug":"生活/必备软件","permalink":"https://miren521.gihub.io/categories/%E7%94%9F%E6%B4%BB/%E5%BF%85%E5%A4%87%E8%BD%AF%E4%BB%B6/"}],"tags":[{"name":"软件","slug":"软件","permalink":"https://miren521.gihub.io/tags/%E8%BD%AF%E4%BB%B6/"},{"name":"windows","slug":"windows","permalink":"https://miren521.gihub.io/tags/windows/"}]},{"title":"vue框架篇","slug":"前端/Vue/指南/vue框架篇","date":"2021-07-06T02:14:14.000Z","updated":"2021-07-10T12:13:04.804Z","comments":true,"path":"ckycsfmlr000gm0wf9sg091br/","link":"","permalink":"https://miren521.gihub.io/ckycsfmlr000gm0wf9sg091br/","excerpt":"本文以前端面试官的角度出发，对 Vue 框架中一些重要的特性、框架的原理以问题的形式进行整理汇总，意在帮助作者及读者自测下 Vue 掌握的程度。","text":"本文以前端面试官的角度出发，对 Vue 框架中一些重要的特性、框架的原理以问题的形式进行整理汇总，意在帮助作者及读者自测下 Vue 掌握的程度。","categories":[{"name":"前端","slug":"前端","permalink":"https://miren521.gihub.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"vue","slug":"前端/vue","permalink":"https://miren521.gihub.io/categories/%E5%89%8D%E7%AB%AF/vue/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://miren521.gihub.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"vue","slug":"vue","permalink":"https://miren521.gihub.io/tags/vue/"},{"name":"指南","slug":"指南","permalink":"https://miren521.gihub.io/tags/%E6%8C%87%E5%8D%97/"}]},{"title":"scroll-view双向联动","slug":"前端/uni-app/学习笔记/scroll-view双向联动","date":"2021-07-01T02:14:14.000Z","updated":"2021-07-10T12:13:04.811Z","comments":true,"path":"ckycsfmlv000rm0wfbnse6qu5/","link":"","permalink":"https://miren521.gihub.io/ckycsfmlv000rm0wfbnse6qu5/","excerpt":"scroll-view的双向联动，主要应用场景为分类菜单，点击左边分类右边自动滑动到对应的分类菜单下，滑动右边分类列表的同时，左边的分类菜单也会同时滑动","text":"scroll-view的双向联动，主要应用场景为分类菜单，点击左边分类右边自动滑动到对应的分类菜单下，滑动右边分类列表的同时，左边的分类菜单也会同时滑动 在得到分类数据的时候，首先得到整个分类列表的高度 12345this.$nextTick(() &#x3D;&gt; &#123; setTimeout(() &#x3D;&gt; &#123; this.setScrollHeight(); &#125;, 1500);&#125;); 1234567891011121314151617181920setScrollHeight() &#123; let h &#x3D; 0; const query &#x3D; uni.createSelectorQuery(); query.selectAll(&#39;.goods-item&#39;).boundingClientRect().exec((res) &#x3D;&gt; &#123; res[0].forEach((item) &#x3D;&gt; &#123; h +&#x3D; item.height; this.goodsHeight.push(h); &#125;) &#125;); this.menuHeight &#x3D; []; let m &#x3D; 0; query.select(&quot;.cu-item&quot;).boundingClientRect().exec((res) &#x3D;&gt; &#123; res[0].forEach((item) &#x3D;&gt; &#123; m +&#x3D; item.height; this.menuHeight.push(m); &#125;) &#125;);&#125; 右边联动 scroll-view中的属性:scroll-into-view=&quot;&#39;main-&#39;+mainCur&quot;，和标题的:id=&quot;&#39;main-&#39;+index&quot;进行相对应的关联；点击左边菜单赋值给mainCur即可 1234TabSelect(e) &#123; this.tabCur &#x3D; e.currentTarget.dataset.id; this.mainCur &#x3D; e.currentTarget.dataset.id;&#125;, 左边联动，重点 上面已经获取到菜单和分类页的高度，根据高度来对菜单加值，减值，实现左边联动滑动的效果右边scroll-view中属性@scroll=&quot;VerticalMain&quot;可监听scroll-view滚动 1234567891011121314151617181920VerticalMain(e) &#123; if (this.goodsHeight.length &#x3D;&#x3D; 0) &#123; return; &#125; let scrollTop &#x3D; e.detail.scrollTop + 10; let current &#x3D; this.tabCur; if (scrollTop &gt;&#x3D; this.verticalNavTop) &#123; if (current + 1 &lt; this.goodsHeight.length &amp;&amp; scrollTop &gt;&#x3D; this.goodsHeight[current]) &#123; this.tabCur &#x3D; current + 1; &#125; &#125; else &#123; if (current - 1 &gt;&#x3D; 0 &amp;&amp; scrollTop &lt; this.goodsHeight[current - 1]) &#123; this.tabCur &#x3D; current - 1; &#125; &#125; this.verticalNavTop &#x3D; scrollTop;&#125;, 优点：如果得到的分类数据标题没有id值，可根据此方法来缺点：代码量比用id来进行赋值多了一些，根据得到的接口数据来使用","categories":[{"name":"前端","slug":"前端","permalink":"https://miren521.gihub.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"uni-app","slug":"前端/uni-app","permalink":"https://miren521.gihub.io/categories/%E5%89%8D%E7%AB%AF/uni-app/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://miren521.gihub.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"uni-app","slug":"uni-app","permalink":"https://miren521.gihub.io/tags/uni-app/"},{"name":"页面操作","slug":"页面操作","permalink":"https://miren521.gihub.io/tags/%E9%A1%B5%E9%9D%A2%E6%93%8D%E4%BD%9C/"}]},{"title":"前端指南-css部分","slug":"前端/学习指南/基础篇/JavaScript","date":"2021-06-08T02:54:14.000Z","updated":"2021-07-10T12:13:04.815Z","comments":true,"path":"ckycsfmmx0045m0wffclm1yue/","link":"","permalink":"https://miren521.gihub.io/ckycsfmmx0045m0wffclm1yue/","excerpt":"这是对于前端-JavaScript部分的学习笔记及分享，会一直更新，保持学习的进步","text":"这是对于前端-JavaScript部分的学习笔记及分享，会一直更新，保持学习的进步 1 闭包 闭包就是能够读取其他函数内部变量的函数 闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域 闭包的特性： 函数内再嵌套函数 内部函数可以引用外层的参数和变量 参数和变量不会被垃圾回收机制回收 说说你对闭包的理解 使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念 闭包 的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中 闭包的另一个用处，是封装对象的私有属性和私有方法 好处：能够实现封装和缓存等； 坏处：就是消耗内存、不正当使用会造成内存溢出的问题 使用闭包的注意点 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露 解决方法是，在退出函数之前，将不使用的局部变量全部删除 2 说说你对作用域链的理解 作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，变量访问到window对象即被终止，作用域链向下访问变量是不被允许的 简单的说，作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期 3 JavaScript原型，原型链 ? 有什么特点？ 每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时 如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，于是就这样一直找下去，也就是我们平时所说的原型链的概念 关系：instance.constructor.prototype = instance.__proto__ 特点： JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变 当我们需要一个属性的时，Javascript引擎会先看当前对象中是否有这个属性， 如果没有的 就会查找他的Prototype对象是否有这个属性，如此递推下去，一直检索到 Object 内建对象 原型： JavaScript的所有对象中都包含了一个 [__proto__] 内部属性，这个属性所对应的就是该对象的原型 JavaScript的函数对象，除了原型 [__proto__] 之外，还预置了 prototype 属性 当函数对象作为构造函数创建实例时，该 prototype 属性值将被作为实例对象的原型 [__proto__]。 原型链： 当一个对象调用的属性/方法自身不存在时，就会去自己 [__proto__] 关联的前辈 prototype 对象上去找 如果没找到，就会去该 prototype 原型 [__proto__] 关联的前辈 prototype 去找。依次类推，直到找到属性/方法或 undefined 为止。从而形成了所谓的“原型链” 原型特点： JavaScript对象是通过引用来传递的，当修改原型时，与之相关的对象也会继承这一改变 4 请解释什么是事件代理 事件代理（Event Delegation），又称之为事件委托。是 JavaScript 中常用绑定事件的常用技巧。顾名思义，“事件代理”即是把原本需要绑定的事件委托给父元素，让父元素担当事件监听的职务。事件代理的原理是DOM元素的事件冒泡。使用事件代理的好处是可以提高性能 可以大量节省内存占用，减少事件注册，比如在table上代理所有td的click事件就非常棒 可以实现当新增子对象时无需再次对其绑定 5 JavaScript如何实现继承？ 构造继承 原型继承 实例继承 拷贝继承 原型prototype机制或apply和call方法去实现较简单，建议使用构造函数与原型混合方式 12345678910111213function Parent()&#123; this.name = &#x27;wang&#x27;;&#125;function Child()&#123; this.age = 28;&#125; Child.prototype = new Parent();//继承了Parent，通过原型var demo = new Child();alert(demo.age);alert(demo.name);//得到被继承的属性 6 谈谈This对象的理解 this总是指向函数的直接调用者（而非间接调用者） 如果有new关键字，this指向new出来的那个对象 在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window 7 事件模型 W3C中定义事件的发生经历三个阶段：捕获阶段（capturing）、目标阶段（targetin）、冒泡阶段（bubbling） 冒泡型事件：当你使用事件冒泡时，子级元素先触发，父级元素后触发 捕获型事件：当你使用事件捕获时，父级元素先触发，子级元素后触发 DOM事件流：同时支持两种事件模型：捕获型事件和冒泡型事件 阻止冒泡：在W3c中，使用stopPropagation()方法；在IE下设置cancelBubble = true 阻止捕获：阻止事件的默认行为，例如click - &lt;a&gt;后的跳转。在W3c中，使用preventDefault()方法，在IE下设置window.event.returnValue = false 8 new操作符具体干了什么呢? 创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型 属性和方法被加入到 this 引用的对象中 新创建的对象由 this 所引用，并且最后隐式的返回 this 9 Ajax原理 Ajax的原理简单来说是在用户和服务器之间加了—个中间层(AJAX引擎)，通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面。使用户操作与服务器响应异步化。这其中最关键的一步就是从服务器获得请求数据 Ajax的过程只涉及JavaScript、XMLHttpRequest和DOM。XMLHttpRequest是ajax的核心机制 123456789101112131415161718/** 1. 创建连接 **/var xhr = null;xhr = new XMLHttpRequest()/** 2. 连接服务器 **/xhr.open(&#x27;get&#x27;, url, true)/** 3. 发送请求 **/xhr.send(null);/** 4. 接受请求 **/xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4)&#123; if(xhr.status == 200)&#123; success(xhr.responseText); &#125; else &#123; /** false **/ fail &amp;&amp; fail(xhr.status); &#125; &#125;&#125; ajax 有那些优缺点? 优点： 通过异步模式，提升了用户体验. 优化了浏览器和服务器之间的传输，减少不必要的数据往返，减少了带宽占用. Ajax在客户端运行，承担了一部分本来由服务器承担的工作，减少了大用户量下的服务器负载。 Ajax可以实现动态不刷新（局部刷新） 缺点： 安全问题 AJAX暴露了与服务器交互的细节。 对搜索引擎的支持比较弱。 不容易调试。 10 如何解决跨域问题? 首先了解下浏览器的同源策略 同源策略/SOP（Same origin policy）是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指”协议+域名+端口“三者相同，即便两个不同的域名指向同一个ip地址，也非同源 那么怎样解决跨域问题的呢？ 通过jsonp跨域 1234567891011var script = document.createElement(&#x27;script&#x27;);script.type = &#x27;text/javascript&#x27;;// 传参并指定回调执行函数为onBackscript.src = &#x27;http://www.....:8080/login?user=admin&amp;callback=onBack&#x27;;document.head.appendChild(script);// 回调执行函数function onBack(res) &#123; alert(JSON.stringify(res));&#125; document.domain + iframe跨域 此方案仅限主域相同，子域不同的跨域应用场景 1.）父窗口：(http://www.domain.com/a.html) 12345&lt;iframe id=&quot;iframe&quot; src=&quot;http://child.domain.com/b.html&quot;&gt;&lt;/iframe&gt;&lt;script&gt; document.domain = &#x27;domain.com&#x27;; var user = &#x27;admin&#x27;;&lt;/script&gt; 2.）子窗口：(http://child.domain.com/b.html) 123document.domain = &#x27;domain.com&#x27;;// 获取父窗口中变量alert(&#x27;get js data from parent ---&gt; &#x27; + window.parent.user); nginx代理跨域 nodejs中间件代理跨域 后端在头部信息里面设置安全域名 11 模块化开发怎么做？ 立即执行函数,不暴露私有成员 12345678910111213var module1 = (function()&#123; var _count = 0; var m1 = function()&#123; //... &#125;; var m2 = function()&#123; //... &#125;; return &#123; m1 : m1, m2 : m2 &#125;;&#125;)(); 12 异步加载JS的方式有哪些？ 设置&lt;script&gt;属性 async=”async” （一旦脚本可用，则会异步执行） 动态创建 script DOM：document.createElement(&#39;script&#39;); XmlHttpRequest 脚本注入 异步加载库 LABjs 模块加载器 Sea.js 13 那些操作会造成内存泄漏？ JavaScript 内存泄露指对象在不需要使用它时仍然存在，导致占用的内存不能使用或回收 未使用 var 声明的全局变量 闭包函数(Closures) 循环引用(两个对象相互引用) 控制台日志(console.log) 移除存在绑定事件的DOM元素(IE) setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏 垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收 14 XML和JSON的区别？ 数据体积方面 JSON相对于XML来讲，数据的体积小，传递的速度更快些。 数据交互方面 JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互 数据描述方面 JSON对数据的描述性比XML较差 传输速度方面 JSON的速度要远远快于XML 15 谈谈你对webpack的看法 WebPack 是一个模块打包工具，你可以使用WebPack管理你的模块依赖，并编绎输出模块们所需的静态文件。它能够很好地管理、打包Web开发中所用到的HTML、Javascript、CSS以及各种静态文件（图片、字体等），让开发过程更加高效。对于不同类型的资源，webpack有对应的模块加载器。webpack模块打包器会分析模块间的依赖关系，最后 生成了优化且合并后的静态资源 16 说说你对AMD和Commonjs的理解 CommonJS是服务器端模块的规范，Node.js采用了这个规范。CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数 AMD推荐的风格通过返回一个对象做为模块对象，CommonJS的风格通过对module.exports或exports的属性赋值来达到暴露模块对象的目的 17 常见web安全及防护原理 sql注入原理 就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令 总的来说有以下几点 永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双&quot;-&quot;进行转换等 永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询存取 永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接 不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息 XSS原理及防范 Xss(cross-site scripting)攻击指的是攻击者往Web页面里插入恶意html标签或者javascript代码。比如：攻击者在论坛中放一个看似安全的链接，骗取用户点击后，窃取cookie中的用户私密信息；或者攻击者在论坛中加一个恶意表单，当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点 XSS防范方法 首先代码里对用户输入的地方和变量都需要仔细检查长度和对”&lt;”,”&gt;”,”;”,”’”等字符做过滤；其次任何内容写到页面之前都必须加以encode，避免不小心把html tag 弄出来。这一个层面做好，至少可以堵住超过一半的XSS 攻击 XSS与CSRF有什么区别吗？ XSS是获取信息，不需要提前知道其他用户页面的代码和数据包。CSRF是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。要完成一次CSRF攻击，受害者必须依次完成两个步骤 登录受信任网站A，并在本地生成Cookie 在不登出A的情况下，访问危险网站B CSRF的防御 服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数 通过验证码的方法 18 用过哪些设计模式？ 工厂模式： 工厂模式解决了重复实例化的问题，但还有一个问题,那就是识别问题，因为根本无法 主要好处就是可以消除对象间的耦合，通过使用工程方法而不是new关键字 构造函数模式 使用构造函数的方法，即解决了重复实例化的问题，又解决了对象识别的问题，该模式与工厂模式的不同之处在于 直接将属性和方法赋值给 this对象; 19 为什么要有同源限制？ 同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议 举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过Javascript读取到你的表单中input中的内容，这样用户名，密码就轻松到手了。 20 常见兼容性问题？ png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8 浏览器默认的margin和padding不同。解决方案是加一个全局的*&#123;margin:0;padding:0;&#125;来统一,，但是全局效率很低，一般是如下这样解决： 1234body,ul,li,ol,dl,dt,dd,form,input,h1,h2,h3,h4,h5,h6,p&#123;margin:0;padding:0;&#125; IE下,event对象有x,y属性,但是没有pageX,pageY属性 Firefox下,event对象有pageX,pageY属性,但是没有x,y属性. 21 说说你对promise的了解 依照 Promise/A+ 的定义，Promise 有四种状态： pending: 初始状态, 非 fulfilled 或 rejected. fulfilled: 成功的操作. rejected: 失败的操作. settled: Promise已被fulfilled或rejected，且不是pending 另外， fulfilled与 rejected一起合称 settled Promise 对象用来进行延迟(deferred) 和异步(asynchronous) 计算 Promise 的构造函数 构造一个 Promise，最基本的用法如下： 123456789101112var promise = new Promise(function(resolve, reject) &#123; if (...) &#123; // succeed resolve(result); &#125; else &#123; // fails reject(Error(errMessage)); &#125; &#125;); Promise 实例拥有 then 方法（具有 then 方法的对象，通常被称为thenable）。它的使用方法如下： 1promise.then(onFulfilled, onRejected) 接收两个函数作为参数，一个在 fulfilled 的时候被调用，一个在rejected的时候被调用，接收参数就是 future，onFulfilled 对应resolve, onRejected对应 reject 22 你觉得jQuery源码有哪些写的好的地方 jquery源码封装在一个匿名函数的自执行环境中，有助于防止变量的全局污染，然后通过传入window对象参数，可以使window对象作为局部变量使用，好处是当jquery中访问window对象的时候，就不用将作用域链退回到顶层作用域了，从而可以更快的访问window对象。同样，传入undefined参数，可以缩短查找undefined时的作用域链 jquery将一些原型属性和方法封装在了jquery.prototype中，为了缩短名称，又赋值给了jquery.fn，这是很形象的写法 有一些数组或对象的方法经常能使用到，jQuery将其保存为局部变量以提高访问速度 jquery实现的链式调用可以节约代码，所返回的都是同一个对象，可以提高代码效率 23 vue、react、angular Vue.js 一个用于创建 web 交互界面的库，是一个精简的 MVVM。它通过双向数据绑定把 View 层和 Model 层连接了起来。实际的 DOM 封装和输出格式都被抽象为了Directives 和 Filters AngularJS 是一个比较完善的前端MVVM框架，包含模板，数据双向绑定，路由，模块化，服务，依赖注入等所有功能，模板功能强大丰富，自带了丰富的 Angular指令 react React 仅仅是 VIEW 层是facebook公司。推出的一个用于构建UI的一个库，能够实现服务器端的渲染。用了virtual dom，所以性能很好。 24 Node的应用场景 特点： 1、它是一个Javascript运行环境 2、依赖于Chrome V8引擎进行代码解释 3、事件驱动 4、非阻塞I/O 5、单进程，单线程 优点： 高并发（最重要的优点） 缺点： 1、只支持单核CPU，不能充分利用CPU 2、可靠性低，一旦代码某个环节崩溃，整个系统都崩溃 27 谈谈你对AMD、CMD的理解 CommonJS是服务器端模块的规范，Node.js采用了这个规范。CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数 AMD推荐的风格通过返回一个对象做为模块对象，CommonJS的风格通过对module.exports或exports的属性赋值来达到暴露模块对象的目的 es6模块 CommonJS、AMD、CMD CommonJS 的规范中，每个 JavaScript 文件就是一个独立的模块上下文（module context），在这个上下文中默认创建的属性都是私有的。也就是说，在一个文件定义的变量（还包括函数和类），都是私有的，对其他文件是不可见的。 CommonJS是同步加载模块,在浏览器中会出现堵塞情况，所以不适用 AMD 异步，需要定义回调define方式 es6 一个模块就是一个独立的文件，该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量 es6还可以导出类、方法，自动适用严格模式 28 那些操作会造成内存泄漏 内存泄漏指任何对象在您不再拥有或需要它之后仍然存在 setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏 闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环） 29 web开发中会话跟踪的方法有哪些cookie、session、url、重写隐藏input、ip地址 30 JS的基本数据类型和引用数据类型 基本数据类型：undefined、null、boolean、number、string、symbol 引用数据类型：object、array、function 31 介绍js有哪些内置对象 Object 是 JavaScript 中所有对象的父对象 数据封装类对象：Object、Array、Boolean、Number 和 String 其他对象：Function、Arguments、Math、Date、RegExp、Error 32 说几条写JavaScript的基本规范 不要在同一行声明多个变量 请使用===/!==来比较true/false或者数值 使用对象字面量替代new Array这种形式 不要使用全局函数 Switch语句必须带有default分支 If语句必须使用大括号 for-in循环中的变量 应该使用var关键字明确限定作用域，从而避免作用域污 33 JavaScript有几种类型的值 栈：原始数据类型（Undefined，Null，Boolean，Number、String） 堆：引用数据类型（对象、数组和函数） 两种类型的区别是：存储位置不同； 原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储； 引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定,如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其 在栈中的地址，取得地址后从堆中获得实体 34 javascript创建对象的几种方式 javascript创建对象简单的说,无非就是使用内置对象或各种自定义对象，当然还可以用JSON；但写法有很多种，也能混合使用 对象字面量的方式 1person=&#123;firstname:&quot;Mark&quot;,lastname:&quot;Yun&quot;,age:25,eyecolor:&quot;black&quot;&#125;; 用function来模拟无参的构造函数 12345678function Person()&#123;&#125; var person=new Person();//定义一个function，如果使用new&quot;实例化&quot;,该function可以看作是一个Class person.name=&quot;Mark&quot;; person.age=&quot;25&quot;; person.work=function()&#123; alert(person.name+&quot; hello...&quot;);&#125;person.work(); 用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性） 12345678910function Pet(name,age,hobby)&#123; this.name=name;//this作用域：当前对象 this.age=age; this.hobby=hobby; this.eat=function()&#123; alert(&quot;我叫&quot;+this.name+&quot;,我喜欢&quot;+this.hobby+&quot;,是个程序员&quot;); &#125;&#125;var maidou =new Pet(&quot;麦兜&quot;,25,&quot;coding&quot;);//实例化、创建对象maidou.eat();//调用eat方法 用工厂方式来创建（内置对象） 1234567var wcDog =new Object(); wcDog.name=&quot;旺财&quot;; wcDog.age=3; wcDog.work=function()&#123; alert(&quot;我是&quot;+wcDog.name+&quot;,汪汪汪......&quot;); &#125; wcDog.work(); 用原型方式来创建 1234567function Dog()&#123;&#125;Dog.prototype.name=&quot;旺财&quot;;Dog.prototype.eat=function()&#123; alert(this.name+&quot;是个吃货&quot;);&#125;var wangcai =new Dog();wangcai.eat(); 用混合方式来创建 123456789function Car(name,price)&#123; this.name=name; this.price=price;&#125;Car.prototype.sell=function()&#123; alert(&quot;我是&quot;+this.name+&quot;，我现在卖&quot;+this.price+&quot;万元&quot;);&#125;var camry =new Car(&quot;凯美瑞&quot;,27);camry.sell(); 35 eval是做什么的 它的功能是把对应的字符串解析成JS代码并运行 应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行） 由JSON字符串转换为JSON对象的时候可以用eval，var obj =eval(&#39;(&#39;+ str +&#39;)&#39;) 36 null，undefined 的区别 undefined 表示不存在这个值。 undefined :是一个表示”无”的原始值或者说表示”缺少值”，就是此处应该有一个值，但是还没有定义。当尝试读取时会返回 undefined 例如变量被声明了，但没有赋值时，就等于undefined null 表示一个对象被定义了，值为“空值” null : 是一个对象(空对象, 没有任何属性和方法) 例如作为函数的参数，表示该函数的参数不是对象； 在验证null时，一定要使用 === ，因为 ==无法分别null 和 undefined 39 JSON 的了解 JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式 它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小 JSON字符串转换为JSON对象: 123var obj =eval(&#x27;(&#x27;+ str +&#x27;)&#x27;);var obj = str.parseJSON();var obj = JSON.parse(str); JSON对象转换为JSON字符串： 12var last=obj.toJSONString();var last=JSON.stringify(obj); 40 js延迟加载的方式有哪些 设置&lt;script&gt;属性 defer=&quot;defer&quot; （脚本将在页面完成解析时执行） 动态创建 script DOM：document.createElement(&#39;script&#39;); XmlHttpRequest 脚本注入 延迟加载工具 LazyLoad 43 defer和async defer并行加载js文件，会按照页面上script标签的顺序执行 async并行加载js文件，下载完成立即执行，不会按照页面上script标签的顺序执行 44 说说严格模式的限制 变量必须声明后再使用 函数的参数不能有同名属性，否则报错 不能使用with语句 不能对只读属性赋值，否则报错 不能使用前缀0表示八进制数，否则报错 不能删除不可删除的属性，否则报错 不能删除变量delete prop，会报错，只能删除属性delete global[prop] eval不会在它的外层作用域引入变量 eval和arguments不能被重新赋值 arguments不会自动反映函数参数的变化 不能使用arguments.callee 不能使用arguments.caller 禁止this指向全局对象 不能使用fn.caller和fn.arguments获取函数调用的堆栈 增加了保留字（比如protected、static和interface） 45 attribute和property的区别是什么 attribute是dom元素在文档中作为html标签拥有的属性； property就是dom元素在js中作为对象拥有的属性。 对于html的标准属性来说，attribute和property是同步的，是会自动更新的 但是对于自定义的属性来说，他们是不同步的 46 谈谈你对ES6的理解 新增模板字符串（为JavaScript提供了简单的字符串插值功能） 箭头函数 for-of（用来遍历数据—例如数组中的值。） arguments对象可被不定参数和默认参数完美代替。 ES6将promise对象纳入规范，提供了原生的Promise对象。 增加了let和const命令，用来声明变量。 增加了块级作用域。 let命令实际上就增加了块级作用域。 还有就是引入module模块的概念 52 谈一谈let与var的区别 let命令不存在变量提升，如果在let前使用，会导致报错 如果块区中存在let和const命令，就会形成封闭作用域 不允许重复声明，因此，不能在函数内部重新声明参数 53 map与forEach的区别 forEach方法，是最基本的方法，就是遍历与循环，默认有3个传参：分别是遍历的数组内容item、数组索引index、和当前遍历数组Array map方法，基本用法与forEach一致，但是不同的，它会返回一个新的数组，所以在callback需要有return值，如果没有，会返回undefined 55 谈一谈箭头函数与普通函数的区别？ 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替 不可以使用yield命令，因此箭头函数不能用作Generator函数 57 异步编程的实现方式 回调函数 优点：简单、容易理解 缺点：不利于维护，代码耦合高 事件监听(采用时间驱动模式，取决于某个事件是否发生)： 优点：容易理解，可以绑定多个事件，每个事件可以指定多个回调函数 缺点：事件驱动型，流程不够清晰 发布/订阅(观察者模式) 类似于事件监听，但是可以通过‘消息中心’，了解现在有多少发布者，多少订阅者 Promise对象 优点：可以利用then方法，进行链式写法；可以书写错误时的回调函数； 缺点：编写和理解，相对比较难 Generator函数 优点：函数体内外的数据交换、错误处理机制 缺点：流程管理不方便 async函数 优点：内置执行器、更好的语义、更广的适用性、返回的是Promise、结构清晰。 缺点：错误处理机制 58 对原生Javascript了解程度 数据类型、运算、对象、Function、继承、闭包、作用域、原型链、事件、RegExp、JSON、Ajax、DOM、BOM、内存泄漏、跨域、异步装载、模板引擎、前端MVC、路由、模块化、Canvas、ECMAScript 59 Js动画与CSS动画区别及相应实现 ```CSS31234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283 的动画的优点 - 在性能上会稍微好一些，浏览器会对&#96;CSS3&#96;的动画做一些优化 - 代码相对简单- 缺点 - 在动画控制上不够灵活 - 兼容性不好- &#96;JavaScript&#96;的动画正好弥补了这两个缺点，控制能力很强，可以单帧的控制、变换，同时写得好完全可以兼容&#96;IE6&#96;，并且功能强大。对于一些复杂控制的动画，使用&#96;javascript&#96;会比较靠谱。而在实现一些小的交互动效的时候，就多考虑考虑&#96;CSS&#96;吧### 60 JS 数组和对象的遍历方式，以及几种方式的比较&gt; 通常我们会用循环的方式来遍历数组。但是循环是 导致js 性能问题的原因之一。一般我们会采用下几种方式来进行数组的遍历- &#96;for in&#96;循环- &#96;for&#96;循环- &#96;forEach&#96; - 这里的 &#96;forEach&#96;回调中两个参数分别为 &#96;value&#96;，&#96;index&#96; - &#96;forEach&#96; 无法遍历对象 - IE不支持该方法；&#96;Firefox&#96; 和 &#96;chrome&#96; 支持 - &#96;forEach&#96; 无法使用 &#96;break&#96;，&#96;continue&#96; 跳出循环，且使用 &#96;return&#96; 是跳过本次循环- 这两种方法应该非常常见且使用很频繁。但实际上，这两种方法都存在性能问题- 在方式一中，&#96;for-in&#96;需要分析出&#96;array&#96;的每个属性，这个操作性能开销很大。用在 &#96;key&#96; 已知的数组上是非常不划算的。所以尽量不要用&#96;for-in&#96;，除非你不清楚要处理哪些属性，例如 &#96;JSON&#96;对象这样的情况- 在方式2中，循环每进行一次，就要检查一下数组长度。读取属性（数组长度）要比读局部变量慢，尤其是当 &#96;array&#96; 里存放的都是 &#96;DOM&#96; 元素，因为每次读取都会扫描一遍页面上的选择器相关元素，速度会大大降低### 61 gulp是什么- &#96;gulp&#96;是前端开发过程中一种基于流的代码构建工具，是自动化项目的构建利器；它不仅能对网站资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成- Gulp的核心概念：流- 流，简单来说就是建立在面向对象基础上的一种抽象的处理数据的工具。在流中，定义了一些处理数据的基本操作，如读取数据，写入数据等，程序员是对流进行所有操作的，而不用关心流的另一头数据的真正流向- gulp正是通过流和代码优于配置的策略来尽量简化任务编写的工作- Gulp的特点： - **易于使用**：通过代码优于配置的策略，gulp 让简单的任务简单，复杂的任务可管理 - **构建快速** 利用 &#96;Node.js&#96; 流的威力，你可以快速构建项目并减少频繁的 &#96;IO&#96; 操作 - **易于学习** 通过最少的 &#96;API&#96;，掌握 &#96;gulp&#96; 毫不费力，构建工作尽在掌握：如同一系列流管道### 64 let var const**let**- 允许你声明一个作用域被限制在块级中的变量、语句或者表达式- let绑定不受变量提升的约束，这意味着let声明不会被提升到当前- 该变量处于从块开始到初始化处理的“暂存死区”**var**- 声明变量的作用域限制在其声明位置的上下文中，而非声明变量总是全局的- 由于变量声明（以及其他声明）总是在任意代码执行之前处理的，所以在代码中的任意位置声明变量总是等效于在代码开头声明**const**- 声明创建一个值的只读引用 (即指针)- 基本数据当值发生改变时，那么其对应的指针也将发生改变，故造成 &#96;const&#96;申明基本数据类型时- 再将其值改变时，将会造成报错， 例如 &#96;const a &#x3D; 3&#96; ; &#96;a &#x3D; 5&#96;时 将会报错- 但是如果是复合类型时，如果只改变复合类型的其中某个&#96;Value&#96;项时， 将还是正常使用### 71 window.onload和$(document).ready&gt; 原生&#96;JS&#96;的&#96;window.onload&#96;与&#96;Jquery&#96;的&#96;$(document).ready(function()&#123;&#125;)&#96;有什么不同？如何用原生JS实现Jq的&#96;ready&#96;方法？- &#96;window.onload()&#96;方法是必须等到页面内包括图片的所有元素加载完毕后才能执行。- &#96;$(document).ready()&#96;是&#96;DOM&#96;结构绘制完毕后就执行，不必等到加载完毕&#96;&#96;&#96;jsfunction ready(fn)&#123; if(document.addEventListener) &#123; &#x2F;&#x2F;标准浏览器 document.addEventListener(&#39;DOMContentLoaded&#39;, function() &#123; &#x2F;&#x2F;注销事件, 避免反复触发 document.removeEventListener(&#39;DOMContentLoaded&#39;,arguments.callee, false); fn(); &#x2F;&#x2F;执行函数 &#125;, false); &#125;else if(document.attachEvent) &#123; &#x2F;&#x2F;IE document.attachEvent(&#39;onreadystatechange&#39;, function() &#123; if(document.readyState &#x3D;&#x3D; &#39;complete&#39;) &#123; document.detachEvent(&#39;onreadystatechange&#39;, arguments.callee); fn(); &#x2F;&#x2F;函数执行 &#125; &#125;); &#125; &#125;; 72 addEventListener()和attachEvent()的区别 addEventListener()是符合W3C规范的标准方法; attachEvent()是IE低版本的非标准方法 addEventListener()支持事件冒泡和事件捕获; - 而attachEvent()只支持事件冒泡 addEventListener()的第一个参数中,事件类型不需要添加on; attachEvent()需要添加&#39;on&#39; 如果为同一个元素绑定多个事件, addEventListener()会按照事件绑定的顺序依次执行, attachEvent()会按照事件绑定的顺序倒序执行 77 使用js实现一个持续的动画效果定时器思路 1234567var e = document.getElementById(&#x27;e&#x27;)var flag = true;var left = 0;setInterval(() =&gt; &#123; left == 0 ? flag = true : left == 100 ? flag = false : &#x27;&#x27; flag ? e.style.left = ` $&#123;left++&#125;px` : e.style.left = ` $&#123;left--&#125;px`&#125;, 1000 / 60) requestAnimationFrame 123456789101112131415161718192021222324//兼容性处理window.requestAnimFrame = (function()&#123; return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function(callback)&#123; window.setTimeout(callback, 1000 / 60); &#125;;&#125;)();var e = document.getElementById(&quot;e&quot;);var flag = true;var left = 0;function render() &#123; left == 0 ? flag = true : left == 100 ? flag = false : &#x27;&#x27;; flag ? e.style.left = ` $&#123;left++&#125;px` : e.style.left = ` $&#123;left--&#125;px`;&#125;(function animloop() &#123; render(); requestAnimFrame(animloop);&#125;)(); 使用css实现一个持续的动画效果 123456animation:mymove 5s infinite;@keyframes mymove &#123; from &#123;top:0px;&#125; to &#123;top:200px;&#125;&#125; animation-name 规定需要绑定到选择器的 keyframe名称。 animation-duration 规定完成动画所花费的时间，以秒或毫秒计。 animation-timing-function 规定动画的速度曲线。 animation-delay 规定在动画开始之前的延迟。 animation-iteration-count 规定动画应该播放的次数。 animation-direction 规定是否应该轮流反向播放动画 80 项目做过哪些性能优化？ 减少 HTTP 请求数 减少 DNS 查询 使用 CDN 避免重定向 图片懒加载 减少 DOM 元素数量 减少DOM 操作 使用外部 JavaScript 和 CSS 压缩 JavaScript 、 CSS 、字体、图片等 优化 CSS Sprite 使用 iconfont 字体裁剪 多域名分发划分内容到不同域名 尽量减少 iframe 使用 避免图片 src 为空 把样式表放在link 中 把JavaScript放在页面底部 81 浏览器缓存 浏览器缓存分为强缓存和协商缓存。当客户端请求某个资源时，获取缓存的流程如下 先根据这个资源的一些 http header 判断它是否命中强缓存，如果命中，则直接从本地获取缓存资源，不会发请求到服务器； 当强缓存没有命中时，客户端会发送请求到服务器，服务器通过另一些request header验证这个资源是否命中协商缓存，称为http再验证，如果命中，服务器将请求返回，但不返回资源，而是告诉客户端直接从缓存中获取，客户端收到返回后就会从缓存中获取资源； 强缓存和协商缓存共同之处在于，如果命中缓存，服务器都不会返回资源； 区别是，强缓存不对发送请求到服务器，但协商缓存会。 当协商缓存也没命中时，服务器就会将资源发送回客户端。 当 ctrl+f5 强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存； 当 f5刷新网页时，跳过强缓存，但是会检查协商缓存； 强缓存 Expires（该字段是 http1.0 时的规范，值为一个绝对时间的 GMT 格式的时间字符串，代表缓存资源的过期时间） Cache-Control:max-age（该字段是 http1.1的规范，强缓存利用其 max-age 值来判断缓存资源的最大生命周期，它的值单位为秒） 协商缓存 Last-Modified（值为资源最后更新时间，随服务器response返回） If-Modified-Since（通过比较两个时间来判断资源在两次请求期间是否有过修改，如果没有修改，则命中协商缓存） ETag（表示资源内容的唯一标识，随服务器response返回） If-None-Match（服务器通过比较请求头部的If-None-Match与当前资源的ETag是否一致来判断资源是否在两次请求之间有过修改，如果没有修改，则命中协商缓存） # 82 WebSocket 由于 http 存在一个明显的弊端（消息只能有客户端推送到服务器端，而服务器端不能主动推送到客户端），导致如果服务器如果有连续的变化，这时只能使用轮询，而轮询效率过低，并不适合。于是 WebSocket被发明出来 相比与 http 具有以下有点 支持双向通信，实时性更强； 可以发送文本，也可以二进制文件； 协议标识符是 ws，加密后是 wss ； 较少的控制开销。连接创建后，ws客户端、服务端进行数据交换时，协议控制的数据包头部较小。在不包含头部的情况下，服务端到客户端的包头只有2~10字节（取决于数据包长度），客户端到服务端的的话，需要加上额外的4字节的掩码。而HTTP协议每次通信都需要携带完整的头部； 支持扩展。ws协议定义了扩展，用户可以扩展协议，或者实现自定义的子协议。（比如支持自定义压缩算法等） 无跨域问题。 实现比较简单，服务端库如 socket.io、ws，可以很好的帮助我们入门。而客户端也只需要参照 api 实现即可 # 83 尽可能多的说出你对 Electron 的理解 最最重要的一点，electron 实际上是一个套了 Chrome 的 nodeJS程序 所以应该是从两个方面说开来 Chrome （无各种兼容性问题）； NodeJS（NodeJS 能做的它也能做） # 84 深浅拷贝浅拷贝 Object.assign 或者展开运算符 深拷贝 可以通过 JSON.parse(JSON.stringify(object)) 来解决 123456789let a = &#123; age: 1, jobs: &#123; first: &#x27;FE&#x27; &#125;&#125;let b = JSON.parse(JSON.stringify(a))a.jobs.first = &#x27;native&#x27;console.log(b.jobs.first) // FE 该方法也是有局限性的 会忽略 undefined 不能序列化函数 不能解决循环引用的对象 # 85 防抖/节流防抖 在滚动事件中需要做个复杂计算或者实现一个按钮的防二次点击操作。可以通过函数防抖动来实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 使用 underscore 的源码来解释防抖动/** * underscore 防抖函数，返回函数连续调用时，空闲时间必须大于或等于 wait，func 才会执行 * * @param &#123;function&#125; func 回调函数 * @param &#123;number&#125; wait 表示时间窗口的间隔 * @param &#123;boolean&#125; immediate 设置为ture时，是否立即调用函数 * @return &#123;function&#125; 返回客户调用函数 */_.debounce = function(func, wait, immediate) &#123; var timeout, args, context, timestamp, result; var later = function() &#123; // 现在和上一次时间戳比较 var last = _.now() - timestamp; // 如果当前间隔时间少于设定时间且大于0就重新设置定时器 if (last &lt; wait &amp;&amp; last &gt;= 0) &#123; timeout = setTimeout(later, wait - last); &#125; else &#123; // 否则的话就是时间到了执行回调函数 timeout = null; if (!immediate) &#123; result = func.apply(context, args); if (!timeout) context = args = null; &#125; &#125; &#125;; return function() &#123; context = this; args = arguments; // 获得时间戳 timestamp = _.now(); // 如果定时器不存在且立即执行函数 var callNow = immediate &amp;&amp; !timeout; // 如果定时器不存在就创建一个 if (!timeout) timeout = setTimeout(later, wait); if (callNow) &#123; // 如果需要立即执行函数的话 通过 apply 执行 result = func.apply(context, args); context = args = null; &#125; return result; &#125;; &#125;; 整体函数实现 对于按钮防点击来说的实现 开始一个定时器，只要我定时器还在，不管你怎么点击都不会执行回调函数。一旦定时器结束并设置为 null，就可以再次点击了 对于延时执行函数来说的实现：每次调用防抖动函数都会判断本次调用和之前的时间间隔，如果小于需要的时间间隔，就会重新创建一个定时器，并且定时器的延时为设定时间减去之前的时间间隔。一旦时间到了，就会执行相应的回调函数 节流 防抖动和节流本质是不一样的。防抖动是将多次执行变为最后一次执行，节流是将多次执行变成每隔一段时间执行 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * underscore 节流函数，返回函数连续调用时，func 执行频率限定为 次 / wait * * @param &#123;function&#125; func 回调函数 * @param &#123;number&#125; wait 表示时间窗口的间隔 * @param &#123;object&#125; options 如果想忽略开始函数的的调用，传入&#123;leading: false&#125;。 * 如果想忽略结尾函数的调用，传入&#123;trailing: false&#125; * 两者不能共存，否则函数不能执行 * @return &#123;function&#125; 返回客户调用函数 */_.throttle = function(func, wait, options) &#123; var context, args, result; var timeout = null; // 之前的时间戳 var previous = 0; // 如果 options 没传则设为空对象 if (!options) options = &#123;&#125;; // 定时器回调函数 var later = function() &#123; // 如果设置了 leading，就将 previous 设为 0 // 用于下面函数的第一个 if 判断 previous = options.leading === false ? 0 : _.now(); // 置空一是为了防止内存泄漏，二是为了下面的定时器判断 timeout = null; result = func.apply(context, args); if (!timeout) context = args = null; &#125;; return function() &#123; // 获得当前时间戳 var now = _.now(); // 首次进入前者肯定为 true // 如果需要第一次不执行函数 // 就将上次时间戳设为当前的 // 这样在接下来计算 remaining 的值时会大于0 if (!previous &amp;&amp; options.leading === false) previous = now; // 计算剩余时间 var remaining = wait - (now - previous); context = this; args = arguments; // 如果当前调用已经大于上次调用时间 + wait // 或者用户手动调了时间 // 如果设置了 trailing，只会进入这个条件 // 如果没有设置 leading，那么第一次会进入这个条件 // 还有一点，你可能会觉得开启了定时器那么应该不会进入这个 if 条件了 // 其实还是会进入的，因为定时器的延时 // 并不是准确的时间，很可能你设置了2秒 // 但是他需要2.2秒才触发，这时候就会进入这个条件 if (remaining &lt;= 0 || remaining &gt; wait) &#123; // 如果存在定时器就清理掉否则会调用二次回调 if (timeout) &#123; clearTimeout(timeout); timeout = null; &#125; previous = now; result = func.apply(context, args); if (!timeout) context = args = null; &#125; else if (!timeout &amp;&amp; options.trailing !== false) &#123; // 判断是否设置了定时器和 trailing // 没有的话就开启一个定时器 // 并且不能不能同时设置 leading 和 trailing timeout = setTimeout(later, remaining); &#125; return result; &#125;; &#125;; # 86 谈谈变量提升？ 当执行 JS 代码时，会生成执行环境，只要代码不是写在函数中的，就是在全局执行环境中，函数中的代码会产生函数执行环境，只此两种执行环境 接下来让我们看一个老生常谈的例子，var 12345678b() // call bconsole.log(a) // undefinedvar a = &#x27;Hello world&#x27;function b() &#123; console.log(&#x27;call b&#x27;)&#125; 变量提升 这是因为函数和变量提升的原因。通常提升的解释是说将声明的代码移动到了顶部，这其实没有什么错误，便于大家理解。但是更准确的解释应该是：在生成执行环境时，会有两个阶段。第一个阶段是创建的阶段，JS 解释器会找出需要提升的变量和函数，并且给他们提前在内存中开辟好空间，函数的话会将整个函数存入内存中，变量只声明并且赋值为 undefined，所以在第二个阶段，也就是代码执行阶段，我们可以直接提前使用 在提升的过程中，相同的函数会覆盖上一个函数，并且函数优先于变量提升 123456789b() // call b secondfunction b() &#123; console.log(&#x27;call b fist&#x27;)&#125;function b() &#123; console.log(&#x27;call b second&#x27;)&#125;var b = &#x27;Hello world&#x27; 复制代码var 会产生很多错误，所以在 ES6中引入了 let。let 不能在声明前使用，但是这并不是常说的 let 不会提升，let 提升了，在第一阶段内存也已经为他开辟好了空间，但是因为这个声明的特性导致了并不能在声明前使用 # 87 什么是单线程，和异步的关系 单线程 - 只有一个线程，只能做一件事 原因 - 避免 1DOM 渲染的冲突 浏览器需要渲染 DOM JS 可以修改 DOM 结构 JS 执行的时候，浏览器 DOM 渲染会暂停 两段 JS 也不能同时执行（都修改 DOM 就冲突了） webworker 支持多线程，但是不能访问 DOM 解决方案 - 异步 90 前端面试之组件化 http://blog.poetries.top/2018/10/20/fe-interview-component/ 89 前端面试之hybrid http://blog.poetries.top/2018/10/20/fe-interview-hybrid/ 92 实现效果，点击容器内的图标，图标边框变成border 1px solid red，点击空白处重置123456789101112131415161718192021const box = document.getElementById(&#x27;box&#x27;);function isIcon(target) &#123; return target.className.includes(&#x27;icon&#x27;);&#125;box.onClick = function(e) &#123; e.stopPropagation(); const target = e.target; if (isIcon(target)) &#123; target.style.border = &#x27;1px solid red&#x27;; &#125;&#125;const doc = document;doc.onclick = function(e) &#123; const children = box.children; for(let i; i &lt; children.length; i++) &#123; if (isIcon(children[i])) &#123; children[i].style.border = &#x27;none&#x27;; &#125; &#125;&#125; 93 请简单实现双向数据绑定mvvm123456789101112&lt;input id=&quot;input&quot;/&gt;const data = &#123;&#125;;const input = document.getElementById(&#x27;input&#x27;);Object.defineProperty(data, &#x27;text&#x27;, &#123; set(value) &#123; input.value = value; this.value = value; &#125;&#125;);input.onChange = function(e) &#123; data.text = e.target.value;&#125; 94 实现Storage，使得该对象为单例，并对localStorage进行封装设置值setItem(key,value)和getItem(key)1234567891011var instance = null;class Storage &#123; static getInstance() &#123; if (!instance) &#123; instance = new Storage(); &#125; return instance; &#125; setItem = (key, value) =&gt; localStorage.setItem(key, value), getItem = key =&gt; localStorage.getItem(key)&#125; 95 说说event loop 首先，js是单线程的，主要的任务是处理用户的交互，而用户的交互无非就是响应DOM的增删改，使用事件队列的形式，一次事件循环只处理一个事件响应，使得脚本执行相对连续，所以有了事件队列，用来储存待执行的事件，那么事件队列的事件从哪里被push进来的呢。那就是另外一个线程叫事件触发线程做的事情了，他的作用主要是在定时触发器线程、异步HTTP请求线程满足特定条件下的回调函数push到事件队列中，等待js引擎空闲的时候去执行，当然js引擎执行过程中有优先级之分，首先js引擎在一次事件循环中，会先执行js线程的主任务，然后会去查找是否有微任务microtask（promise），如果有那就优先执行微任务，如果没有，在去查找宏任务macrotask（setTimeout、setInterval）进行执行 众所周知 JS 是门非阻塞单线程语言，因为在最初 JS 就是为了和浏览器交互而诞生的。如果 JS 是门多线程的语言话，我们在多个线程中处理 DOM 就可能会发生问题（一个线程中新加节点，另一个线程中删除节点） JS 在执行的过程中会产生执行环境，这些执行环境会被顺序的加入到执行栈中。如果遇到异步的代码，会被挂起并加入到 Task（有多种 task） 队列中。一旦执行栈为空，Event Loop 就会从 Task 队列中拿出需要执行的代码并放入执行栈中执行，所以本质上来说 JS 中的异步还是同步行为 1234567console.log(&#x27;script start&#x27;);setTimeout(function() &#123; console.log(&#x27;setTimeout&#x27;);&#125;, 0);console.log(&#x27;script end&#x27;); 不同的任务源会被分配到不同的 Task 队列中，任务源可以分为 微任务（microtask） 和 宏任务（macrotask）。在 ES6 规范中，microtask 称为 jobs，macrotask 称为 task 1234567891011121314151617console.log(&#x27;script start&#x27;);setTimeout(function() &#123; console.log(&#x27;setTimeout&#x27;);&#125;, 0);new Promise((resolve) =&gt; &#123; console.log(&#x27;Promise&#x27;) resolve()&#125;).then(function() &#123; console.log(&#x27;promise1&#x27;);&#125;).then(function() &#123; console.log(&#x27;promise2&#x27;);&#125;);console.log(&#x27;script end&#x27;);// script start =&gt; Promise =&gt; script end =&gt; promise1 =&gt; promise2 =&gt; setTimeout 以上代码虽然 setTimeout 写在 Promise 之前，但是因为 Promise 属于微任务而 setTimeout 属于宏任务 微任务 process.nextTick promise Object.observe MutationObserver 宏任务 script setTimeout setInterval setImmediate I/O UI rendering 宏任务中包括了 script ，浏览器会先执行一个宏任务，接下来有异步代码的话就先执行微任务 所以正确的一次 Event loop 顺序是这样的 执行同步代码，这属于宏任务 执行栈为空，查询是否有微任务需要执行 执行所有微任务 必要的话渲染 UI 然后开始下一轮 Event loop，执行宏任务中的异步代码 通过上述的 Event loop 顺序可知，如果宏任务中的异步代码有大量的计算并且需要操作 DOM 的话，为了更快的响应界面响应，我们可以把操作 DOM 放入微任务中 96 说说事件流事件流分为两种，捕获事件流和冒泡事件流 捕获事件流从根节点开始执行，一直往子节点查找执行，直到查找执行到目标节点 冒泡事件流从目标节点开始执行，一直往父节点冒泡查找执行，直到查到到根节点 事件流分为三个阶段，一个是捕获节点，一个是处于目标节点阶段，一个是冒泡阶段 98 我现在有一个canvas，上面随机布着一些黑块，请实现方法，计算canvas上有多少个黑块 https://www.jianshu.com/p/f54d265f7aa4 99 请手写实现一个promise https://segmentfault.com/a/1190000013396601 100 说说从输入URL到看到页面发生的全过程，越详细越好 首先浏览器主进程接管，开了一个下载线程。 然后进行HTTP请求（DNS查询、IP寻址等等），中间会有三次捂手，等待响应，开始下载响应报文。 将下载完的内容转交给Renderer进程管理。 Renderer进程开始解析css rule tree和dom tree，这两个过程是并行的，所以一般我会把link标签放在页面顶部。 解析绘制过程中，当浏览器遇到link标签或者script、img等标签，浏览器会去下载这些内容，遇到时候缓存的使用缓存，不适用缓存的重新下载资源。 css rule tree和dom tree生成完了之后，开始合成render tree，这个时候浏览器会进行layout，开始计算每一个节点的位置，然后进行绘制。 绘制结束后，关闭TCP连接，过程有四次挥手 101 描述一下this this，函数执行的上下文，可以通过apply，call，bind改变this的指向。对于匿名函数或者直接调用的函数来说，this指向全局上下文（浏览器为window，NodeJS为global），剩下的函数调用，那就是谁调用它，this就指向谁。当然还有es6的箭头函数，箭头函数的指向取决于该箭头函数声明的位置，在哪里声明，this就指向哪里 102 说一下浏览器的缓存机制 浏览器缓存机制有两种，一种为强缓存，一种为协商缓存 对于强缓存，浏览器在第一次请求的时候，会直接下载资源，然后缓存在本地，第二次请求的时候，直接使用缓存。 对于协商缓存，第一次请求缓存且保存缓存标识与时间，重复请求向服务器发送缓存标识和最后缓存时间，服务端进行校验，如果失效则使用缓存 协商缓存相关设置 Exprires：服务端的响应头，第一次请求的时候，告诉客户端，该资源什么时候会过期。Exprires的缺陷是必须保证服务端时间和客户端时间严格同步。 Cache-control：max-age：表示该资源多少时间后过期，解决了客户端和服务端时间必须同步的问题， If-None-Match/ETag：缓存标识，对比缓存时使用它来标识一个缓存，第一次请求的时候，服务端会返回该标识给客户端，客户端在第二次请求的时候会带上该标识与服务端进行对比并返回If-None-Match标识是否表示匹配。 Last-modified/If-Modified-Since：第一次请求的时候服务端返回Last-modified表明请求的资源上次的修改时间，第二次请求的时候客户端带上请求头If-Modified-Since，表示资源上次的修改时间，服务端拿到这两个字段进行对比 # 103 现在要你完成一个Dialog组件，说说你设计的思路？它应该有什么功能？ 该组件需要提供hook指定渲染位置，默认渲染在body下面。 然后改组件可以指定外层样式，如宽度等 组件外层还需要一层mask来遮住底层内容，点击mask可以执行传进来的onCancel函数关闭Dialog。 另外组件是可控的，需要外层传入visible表示是否可见。 然后Dialog可能需要自定义头head和底部footer，默认有头部和底部，底部有一个确认按钮和取消按钮，确认按钮会执行外部传进来的onOk事件，然后取消按钮会执行外部传进来的onCancel事件。 当组件的visible为true时候，设置body的overflow为hidden，隐藏body的滚动条，反之显示滚动条。 组件高度可能大于页面高度，组件内部需要滚动条。 只有组件的visible有变化且为ture时候，才重渲染组件内的所有内容 # 104 caller和callee的区别callee caller返回一个函数的引用，这个函数调用了当前的函数。 使用这个属性要注意 这个属性只有当函数在执行时才有用 如果在javascript程序中，函数是由顶层调用的，则返回null functionName.caller: functionName是当前正在执行的函数。 123function a() &#123; console.log(a.caller)&#125; callee callee放回正在执行的函数本身的引用，它是arguments的一个属性 使用callee时要注意: 这个属性只有在函数执行时才有效 它有一个length属性，可以用来获得形参的个数，因此可以用来比较形参和实参个数是否一致，即比较arguments.length是否等于arguments.callee.length 它可以用来递归匿名函数。 123function a() &#123; console.log(arguments.callee)&#125; # 105 ajax、axios、fetch区别jQuery ajax 12345678$.ajax(&#123; type: &#x27;POST&#x27;, url: url, data: data, dataType: dataType, success: function () &#123;&#125;, error: function () &#123;&#125;&#125;); 优缺点： 本身是针对MVC的编程,不符合现在前端MVVM的浪潮 基于原生的XHR开发，XHR本身的架构不清晰，已经有了fetch的替代方案 JQuery整个项目太大，单纯使用ajax却要引入整个JQuery非常的不合理（采取个性化打包的方案又不能享受CDN服务） axios 1234567891011121314axios(&#123; method: &#x27;post&#x27;, url: &#x27;/user/12345&#x27;, data: &#123; firstName: &#x27;Fred&#x27;, lastName: &#x27;Flintstone&#x27; &#125;&#125;).then(function (response) &#123; console.log(response);&#125;).catch(function (error) &#123; console.log(error);&#125;); 优缺点： 从浏览器中创建 XMLHttpRequest 从 node.js 发出 http 请求 支持 Promise API 拦截请求和响应 转换请求和响应数据 取消请求 自动转换JSON数据 客户端支持防止CSRF/XSRF fetch 12345678try &#123; let response = await fetch(url); let data = response.json(); console.log(data);&#125; catch(e) &#123; console.log(&quot;Oops, error&quot;, e);&#125; 优缺点： fetcht只对网络请求报错，对400，500都当做成功的请求，需要封装去处理 fetch默认不会带cookie，需要添加配置项 fetch不支持abort，不支持超时控制，使用setTimeout及Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成了量的浪费 fetch没有办法原生监测请求的进度，而XHR可以 110 如何编写高性能的JavaScript 遵循严格模式：&quot;use strict&quot;; 将js脚本放在页面底部，加快渲染页面 将js脚本将脚本成组打包，减少请求 使用非阻塞方式下载js脚本 尽量使用局部变量来保存全局变量 尽量减少使用闭包 使用 window 对象属性方法时，省略 window 尽量减少对象成员嵌套 缓存 DOM 节点的访问 通过避免使用 eval() 和 Function() 构造器 给 setTimeout() 和 setInterval() 传递函数而不是字符串作为参数 尽量使用直接量创建对象和数组 最小化重绘(repaint)和回流(reflow) # 111 描述浏览器的渲染过程，DOM树和渲染树的区别 浏览器的渲染过程： 解析HTML构建 DOM(DOM树)，并行请求 css/image/js CSS 文件下载完成，开始构建 CSSOM(CSS树) CSSOM 构建结束后，和 DOM 一起生成 Render Tree(渲染树) 布局(Layout)：计算出每个节点在屏幕中的位置 显示(Painting)：通过显卡把页面画到屏幕上 DOM树 和 渲染树 的区别： DOM树与HTML标签一一对应，包括head和隐藏元素 渲染树不包括head和隐藏元素，大段文本的每一个行都是独立节点，每一个节点都有对应的css属性 # 112 script 的位置是否会影响首屏显示时间 在解析 HTML 生成 DOM 过程中，js 文件的下载是并行的，不需要 DOM 处理到 script 节点。因此，script的位置不影响首屏显示的开始时间。 浏览器解析 HTML 是自上而下的线性过程，script作为 HTML 的一部分同样遵循这个原则 因此，script 会延迟 DomContentLoad，只显示其上部分首屏内容，从而影响首屏显示的完成时间 # 113 解释JavaScript中的作用域与变量声明提升 JavaScript作用域： 在Java、C等语言中，作用域为for语句、if语句或&#123;&#125;内的一块区域，称为作用域； 而在 JavaScript 中，作用域为function()&#123;&#125;内的区域，称为函数作用域。 JavaScript变量声明提升： 在JavaScript中，函数声明与变量声明经常被JavaScript引擎隐式地提升到当前作用域的顶部。 声明语句中的赋值部分并不会被提升，只有名称被提升 函数声明的优先级高于变量，如果变量名跟函数名相同且未赋值，则函数声明会覆盖变量声明 如果函数有多个同名参数，那么最后一个参数（即使没有定义）会覆盖前面的同名参数 # 114 JavaScript有几种类型的值？，你能画一下他们的内存图吗 原始数据类型（Undefined，Null，Boolean，Number、String）– 栈 引用数据类型（对象、数组和函数）– 堆 两种类型的区别是：存储位置不同： 原始数据类型是直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据； 引用数据类型存储在堆(heap)中的对象，占据空间大、大小不固定，如果存储在栈中，将会影响程序运行的性能； 引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。 当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。 # 115 JavaScript如何实现一个类，怎么实例化这个类 构造函数法（ 1this + 1prototype ） – 用 1new 关键字 生成实例对象 缺点：用到了 this 和 prototype，编写复杂，可读性差 123456789function Mobile(name, price)&#123; this.name = name; this.price = price;&#125;Mobile.prototype.sell = function()&#123; alert(this.name + &quot;，售价 $&quot; + this.price);&#125;var iPhone7 = new Mobile(&quot;iPhone7&quot;, 1000);iPhone7.sell(); Object.create 法 – 用 Object.create() 生成实例对象 缺点：不能实现私有属性和私有方法，实例对象之间也不能共享数据 1234567891011121314151617181920var Person = &#123; firstname: &quot;Mark&quot;, lastname: &quot;Yun&quot;, age: 25, introduce: function()&#123; alert(&#x27;I am &#x27; + Person.firstname + &#x27; &#x27; + Person.lastname); &#125;&#125;;var person = Object.create(Person);person.introduce();// Object.create 要求 IE9+，低版本浏览器可以自行部署：if (!Object.create) &#123; Object.create = function (o) &#123; function F() &#123;&#125; F.prototype = o; return new F(); &#125;; &#125; 极简主义法（消除 1this 和 1prototype ） – 调用 1createNew() 得到实例对象 优点：容易理解，结构清晰优雅，符合传统的”面向对象编程”的构造 12345678910111213141516171819var Cat = &#123; age: 3, // 共享数据 -- 定义在类对象内，createNew() 外 createNew: function () &#123; var cat = &#123;&#125;; // var cat = Animal.createNew(); // 继承 Animal 类 cat.name = &quot;小咪&quot;; var sound = &quot;喵喵喵&quot;; // 私有属性--定义在 createNew() 内，输出对象外 cat.makeSound = function () &#123; alert(sound); // 暴露私有属性 &#125;; cat.changeAge = function(num)&#123; Cat.age = num; // 修改共享数据 &#125;; return cat; // 输出对象 &#125;&#125;;var cat = Cat.createNew();cat.makeSound(); ES6 语法糖 class – 用 new 关键字 生成实例对象 1234567891011class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return &#x27;(&#x27; + this.x + &#x27;, &#x27; + this.y + &#x27;)&#x27;; &#125;&#125;var point = new Point(2, 3); # 116 Javascript如何实现继承 构造函数绑定：使用 call 或 apply 方法，将父对象的构造函数绑定在子对象上 12345function Cat(name,color)&#123; Animal.apply(this, arguments); this.name = name; this.color = color;&#125; 实例继承：将子对象的 prototype 指向父对象的一个实例 12Cat.prototype = new Animal();Cat.prototype.constructor = Cat; 拷贝继承：如果把父对象的所有属性和方法，拷贝进子对象 12345678function extend(Child, Parent) &#123; var p = Parent.prototype; var c = Child.prototype; for (var i in p) &#123; c[i] = p[i]; &#125; c.uber = p; &#125; 原型继承：将子对象的 prototype 指向父对象的 prototype 1234567function extend(Child, Parent) &#123; var F = function()&#123;&#125;; F.prototype = Parent.prototype; Child.prototype = new F(); Child.prototype.constructor = Child; Child.uber = Parent.prototype;&#125; 1ES6&#96; 语法糖 &#96;extends：class ColorPoint extends Point &#123;&#125; 123456789class ColorPoint extends Point &#123; constructor(x, y, color) &#123; super(x, y); // 调用父类的constructor(x, y) this.color = color; &#125; toString() &#123; return this.color + &#x27; &#x27; + super.toString(); // 调用父类的toString() &#125;&#125; 121 什么是函数节流？介绍一下应用场景和原理？ 函数节流(throttle)是指阻止一个函数在很短时间间隔内连续调用。 只有当上一次函数执行后达到规定的时间间隔，才能进行下一次调用。 但要保证一个累计最小调用间隔（否则拖拽类的节流都将无连续效果） 函数节流用于 onresize, onscroll 等短时间内会多次触发的事件 函数节流的原理：使用定时器做时间节流。 当触发一个事件时，先用 setTimout 让这个事件延迟一小段时间再执行。 如果在这个时间间隔内又触发了事件，就 clearTimeout 原来的定时器， 再 setTimeout 一个新的定时器重复以上流程。 函数节流简单实现： 12345678910function throttle(method, context) &#123; clearTimeout(methor.tId); method.tId = setTimeout(function()&#123; method.call(context); &#125;， 100); // 两次调用至少间隔 100ms&#125;// 调用window.onresize = function()&#123; throttle(myFunc, window);&#125; # 122 区分什么是“客户区坐标”、“页面坐标”、“屏幕坐标” 客户区坐标：鼠标指针在可视区中的水平坐标(clientX)和垂直坐标(clientY) 页面坐标：鼠标指针在页面布局中的水平坐标(pageX)和垂直坐标(pageY) 屏幕坐标：设备物理屏幕的水平坐标(screenX)和垂直坐标(screenY) 如何获得一个DOM元素的绝对位置？ elem.offsetLeft：返回元素相对于其定位父级左侧的距离 elem.offsetTop：返回元素相对于其定位父级顶部的距离 elem.getBoundingClientRect()：返回一个DOMRect对象，包含一组描述边框的只读属性，单位像素 124 Javascript垃圾回收方法 标记清除（mark and sweep） 这是JavaScript最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境” 垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量（闭包），在这些完成之后仍存在标记的就是要删除的变量了 引用计数(reference counting) 在低版本IE中经常会出现内存泄露，很多时候就是因为其采用引用计数方式进行垃圾回收。引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个 变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加1，如果该变量的值变成了另外一个，则这个值得引用次数减1，当这个值的引用次数变为0的时 候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为0的值占用的空间 # 125 请解释一下 JavaScript 的同源策略 概念:同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议 指一段脚本只能读取来自同一来源的窗口和文档的属性 为什么要有同源限制？ 我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过Javascript读取到你的表单中input中的内容，这样用户名，密码就轻松到手了。 缺点 现在网站的JS都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严格模式的文件，被 merge后，这个串就到了文件的中间，不仅没有指示严格模式，反而在压缩后浪费了字节 # 126 如何删除一个cookie 将时间设为当前时间往前一点 123var date = new Date();date.setDate(date.getDate() - 1);//真正的删除 setDate()方法用于设置一个月的某一天 expires的设置 1document.cookie = &#x27;user=&#x27;+ encodeURIComponent(&#x27;name&#x27;) + &#x27;;expires = &#x27; + new Date(0) 129 JavaScript 中，调用函数有哪几种方式 方法调用模式 Foo.foo(arg1, arg2); 函数调用模式 foo(arg1, arg2); 构造器调用模式 (new Foo())(arg1, arg2); call/applay调用模式 Foo.foo.call(that, arg1, arg2); bind调用模式 Foo.foo.bind(that)(arg1, arg2)(); # 130 简单实现 Function.bind 函数12345678910111213if (!Function.prototype.bind) &#123; Function.prototype.bind = function(that) &#123; var func = this, args = arguments; return function() &#123; return func.apply(that, Array.prototype.slice.call(args, 1)); &#125; &#125;&#125;// 只支持 bind 阶段的默认参数：func.bind(that, arg1, arg2)();// 不支持以下调用阶段传入的参数：func.bind(that)(arg1, arg2); # 131 列举一下JavaScript数组和对象有哪些原生方法？数组： arr.concat(arr1, arr2, arrn); arr.join(&quot;,&quot;); arr.sort(func); arr.pop(); arr.push(e1, e2, en); arr.shift(); unshift(e1, e2, en); arr.reverse(); arr.slice(start, end); arr.splice(index, count, e1, e2, en); arr.indexOf(el); arr.includes(el); // ES6 对象： object.hasOwnProperty(prop); object.propertyIsEnumerable(prop); object.valueOf(); object.toString(); object.toLocaleString(); Class.prototype.isPropertyOf(object); # 132 Array.splice() 与 Array.splice() 的区别？slice “读取”数组指定的元素，不会对原数组进行修改 语法：arr.slice(start, end) start 指定选取开始位置（含） end 指定选取结束位置（不含） splice “操作”数组指定的元素，会修改原数组，返回被删除的元素 语法：arr.splice(index, count, [insert Elements]) index 是操作的起始位置 count = 0 插入元素，count &gt; 0 删除元素 [insert Elements] 向数组新插入的元素 # 133 MVVMMVVM 由以下三个内容组成 View：界面 Model：数据模型 ViewModel：作为桥梁负责沟通 View 和 Model 在 JQuery 时期，如果需要刷新 UI 时，需要先取到对应的 DOM 再更新 UI，这样数据和业务的逻辑就和页面有强耦合 在 MVVM 中，UI 是通过数据驱动的，数据一旦改变就会相应的刷新对应的 UI，UI 如果改变，也会改变对应的数据。这种方式就可以在业务处理中只关心数据的流转，而无需直接和页面打交道。ViewModel 只关心数据和业务的处理，不关心 View 如何处理数据，在这种情况下，View 和 Model 都可以独立出来，任何一方改变了也不一定需要改变另一方，并且可以将一些可复用的逻辑放在一个 ViewModel 中，让多个 View 复用这个 ViewModel 在 MVVM 中，最核心的也就是数据双向绑定，例如 Angluar 的脏数据检测，Vue 中的数据劫持 脏数据检测 当触发了指定事件后会进入脏数据检测，这时会调用 $digest 循环遍历所有的数据观察者，判断当前值是否和先前的值有区别，如果检测到变化的话，会调用 $watch 函数，然后再次调用 $digest 循环直到发现没有变化。循环至少为二次 ，至多为十次 脏数据检测虽然存在低效的问题，但是不关心数据是通过什么方式改变的，都可以完成任务，但是这在 Vue 中的双向绑定是存在问题的。并且脏数据检测可以实现批量检测出更新的值，再去统一更新 UI，大大减少了操作 DOM 的次数 数据劫持 Vue 内部使用了 Obeject.defineProperty() 来实现双向绑定，通过这个函数可以监听到 set 和 get的事件 12345678910111213141516171819202122232425262728293031var data = &#123; name: &#x27;yck&#x27; &#125;observe(data)let name = data.name // -&gt; get valuedata.name = &#x27;yyy&#x27; // -&gt; change valuefunction observe(obj) &#123; // 判断类型 if (!obj || typeof obj !== &#x27;object&#x27;) &#123; return &#125; Object.keys(data).forEach(key =&gt; &#123; defineReactive(data, key, data[key]) &#125;)&#125;function defineReactive(obj, key, val) &#123; // 递归子属性 observe(val) Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get: function reactiveGetter() &#123; console.log(&#x27;get value&#x27;) return val &#125;, set: function reactiveSetter(newVal) &#123; console.log(&#x27;change value&#x27;) val = newVal &#125; &#125;)&#125; 以上代码简单的实现了如何监听数据的 set 和 get 的事件，但是仅仅如此是不够的，还需要在适当的时候给属性添加发布订阅 123&lt;div&gt; &#123;&#123;name&#125;&#125;&lt;/div&gt; 在解析如上模板代码时，遇到 &#123;name&#125; 就会给属性 name 添加发布订阅 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 通过 Dep 解耦class Dep &#123; constructor() &#123; this.subs = [] &#125; addSub(sub) &#123; // sub 是 Watcher 实例 this.subs.push(sub) &#125; notify() &#123; this.subs.forEach(sub =&gt; &#123; sub.update() &#125;) &#125;&#125;// 全局属性，通过该属性配置 WatcherDep.target = nullfunction update(value) &#123; document.querySelector(&#x27;div&#x27;).innerText = value&#125;class Watcher &#123; constructor(obj, key, cb) &#123; // 将 Dep.target 指向自己 // 然后触发属性的 getter 添加监听 // 最后将 Dep.target 置空 Dep.target = this this.cb = cb this.obj = obj this.key = key this.value = obj[key] Dep.target = null &#125; update() &#123; // 获得新值 this.value = this.obj[this.key] // 调用 update 方法更新 Dom this.cb(this.value) &#125;&#125;var data = &#123; name: &#x27;yck&#x27; &#125;observe(data)// 模拟解析到 `&#123;&#123;name&#125;&#125;` 触发的操作new Watcher(data, &#x27;name&#x27;, update)// update Dom innerTextdata.name = &#x27;yyy&#x27; 接下来,对 defineReactive 函数进行改造 1234567891011121314151617181920212223function defineReactive(obj, key, val) &#123; // 递归子属性 observe(val) let dp = new Dep() Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get: function reactiveGetter() &#123; console.log(&#x27;get value&#x27;) // 将 Watcher 添加到订阅 if (Dep.target) &#123; dp.addSub(Dep.target) &#125; return val &#125;, set: function reactiveSetter(newVal) &#123; console.log(&#x27;change value&#x27;) val = newVal // 执行 watcher 的 update 方法 dp.notify() &#125; &#125;)&#125; 以上实现了一个简易的双向绑定，核心思路就是手动触发一次属性的 getter 来实现发布订阅的添加 Proxy 与 Obeject.defineProperty 对比 ```Obeject.defineProperty 12345678910111213141516171819202122232425262728293031323334353637 虽然已经能够实现双向绑定了，但是他还是有缺陷的。 - 只能对属性进行数据劫持，所以需要深度遍历整个对象 - 对于数组不能监听到数据的变化&gt; 虽然 &#96;Vue&#96; 中确实能检测到数组数据的变化，但是其实是使用了 &#96;hack&#96; 的办法，并且也是有缺陷的### 134 WEB应用从服务器主动推送Data到客户端有那些方式- &#96;AJAX&#96; 轮询- &#96;html5&#96; 服务器推送事件 &#96;(new EventSource(SERVER_URL)).addEventListener(&quot;message&quot;, func);&#96;- html5 Websocket- &#96;(new WebSocket(SERVER_URL)).addEventListener(&quot;message&quot;, func);&#96;### [#](http:&#x2F;&#x2F;interview.poetries.top&#x2F;docs&#x2F;base.html#_135-继承) 135 继承- **原型链继承**，将父类的实例作为子类的原型，他的特点是实例是子类的实例也是父类的实例，父类新增的原型方法&#x2F;属性，子类都能够访问，并且原型链继承简单易于实现，缺点是来自原型对象的所有属性被所有实例共享，无法实现多继承，无法向父类构造函数传参。- **构造继承**，使用父类的构造函数来增强子类实例，即复制父类的实例属性给子类，构造继承可以向父类传递参数，可以实现多继承，通过&#96;call&#96;多个父类对象。但是构造继承只能继承父类的实例属性和方法，不能继承原型属性和方法，无法实现函数服用，每个子类都有父类实例函数的副本，影响性能- **实例继承**，为父类实例添加新特性，作为子类实例返回，实例继承的特点是不限制调用方法，不管是new 子类（）还是子类（）返回的对象具有相同的效果，缺点是实例是父类的实例，不是子类的实例，不支持多继承- **拷贝继承**：特点：支持多继承，缺点：效率较低，内存占用高（因为要拷贝父类的属性）无法获取父类不可枚举的方法（不可枚举方法，不能使用&#96;for in&#96;访问到）- **组合继承**：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用- **寄生组合继承**：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法&#x2F;属性，避免的组合继承的缺点### [#](http:&#x2F;&#x2F;interview.poetries.top&#x2F;docs&#x2F;base.html#_136-this指向) 136 this指向**1. this 指向有哪几种**- 默认绑定：全局环境中，&#96;this&#96;默认绑定到&#96;window&#96;- 隐式绑定：一般地，被直接对象所包含的函数调用时，也称为方法调用，&#96;this&#96;隐式绑定到该直接对象- 隐式丢失：隐式丢失是指被隐式绑定的函数丢失绑定对象，从而默认绑定到&#96;window&#96;。显式绑定：通过&#96;call()&#96;、&#96;apply()&#96;、&#96;bind()&#96;方法把对象绑定到&#96;this&#96;上，叫做显式绑定- &#96;&#96;&#96; new 绑定：如果函数或者方法调用之前带有关键字 1new ，它就构成构造函数调用。对于 1this 绑定来说，称为 1new 绑定 构造函数通常不使用return关键字，它们通常初始化新对象，当构造函数的函数体执行完毕时，它会显式返回。在这种情况下，构造函数调用表达式的计算结果就是这个新对象的值 如果构造函数使用return语句但没有指定返回值，或者返回一个原始值，那么这时将忽略返回值，同时使用这个新对象作为调用结果 如果构造函数显式地使用return语句返回一个对象，那么调用表达式的值就是这个对象 2. 改变函数内部 this 指针的指向函数（bind，apply，call的区别） apply：调用一个对象的一个方法，用另一个对象替换当前对象。例如：B.apply(A, arguments);即A对象应用B对象的方法 call：调用一个对象的一个方法，用另一个对象替换当前对象。例如：B.call(A, args1,args2);即A对象调用B对象的方法 bind除了返回是函数以外，它的参数和call一样 3. 箭头函数 箭头函数没有this，所以需要通过查找作用域链来确定this的值，这就意味着如果箭头函数被非箭头函数包含，this绑定的就是最近一层非箭头函数的this， 箭头函数没有自己的arguments对象，但是可以访问外围函数的arguments对象 不能通过new关键字调用，同样也没有new.target值和原型 138 加载1. 异步加载js的方法 defer：只支持IE如果您的脚本不会改变文档的内容，可将 defer 属性加入到&lt;script&gt;标签中，以便加快处理文档的速度。因为浏览器知道它将能够安全地读取文档的剩余部分而不用执行脚本，它将推迟对脚本的解释，直到文档已经显示给用户为止 async：HTML5 属性，仅适用于外部脚本；并且如果在IE中，同时存在defer和async，那么defer的优先级比较高；脚本将在页面完成时执行 2. 图片的懒加载和预加载 预加载：提前加载图片，当用户需要查看时可直接从本地缓存中渲染。 懒加载：懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数 两种技术的本质：两者的行为是相反的，一个是提前加载，一个是迟缓甚至不加载。懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。 # 139 垃圾回收 找出那些不再继续使用的变 量，然后释放其占用的内存。为此，垃圾收集器会按照固定的时间间隔(或代码执行中预定的收集时间)， 周期性地执行这一操作。 标记清除 先所有都加上标记，再把环境中引用到的变量去除标记。剩下的就是没用的了 引用计数 跟踪记录每 个值被引用的次数。清除引用次数为0的变量 ⚠️会有循环引用问题 。循环引用如果大量存在就会导致内存泄露。","categories":[{"name":"前端","slug":"前端","permalink":"https://miren521.gihub.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"基础","slug":"前端/基础","permalink":"https://miren521.gihub.io/categories/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://miren521.gihub.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://miren521.gihub.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"基础","slug":"基础","permalink":"https://miren521.gihub.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://miren521.gihub.io/tags/JavaScript/"}]},{"title":"前端指南-css部分","slug":"前端/学习指南/基础篇/CSS部分","date":"2021-06-02T03:20:14.000Z","updated":"2021-07-10T12:13:04.813Z","comments":true,"path":"ckycsfmmp003cm0wffvhj749o/","link":"","permalink":"https://miren521.gihub.io/ckycsfmmp003cm0wffvhj749o/","excerpt":"这是对于前端-css部分的学习笔记及分享，会一直更新，保持学习的进步","text":"这是对于前端-css部分的学习笔记及分享，会一直更新，保持学习的进步 1 css sprite是什么,有什么优缺点 概念：将多个小图片拼接到一个图片中。通过background-position和元素尺寸调节需要显示的背景图案。 优点： 减少HTTP请求数，极大地提高页面加载速度 增加图片信息重复度，提高压缩比，减少图片大小 更换风格方便，只需在一张或几张图片上修改颜色或样式即可实现 缺点： 图片合并麻烦 维护麻烦，修改一个图片可能需要从新布局整个图片，样式 2 display: none;与visibility: hidden;的区别 联系：它们都能让元素不可见 区别： display:none;会让元素完全从渲染树中消失，渲染的时候不占据任何空间；visibility: hidden;不会让元素从渲染树消失，渲染师元素继续占据空间，只是内容不可见 display: none;是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示；visibility: hidden;是继承属性，子孙节点消失由于继承了hidden，通过设置visibility: visible;可以让子孙节点显式 修改常规流中元素的display通常会造成文档重排。修改visibility属性只会造成本元素的重绘。 读屏器不会读取display: none;元素内容；会读取visibility: hidden;元素内容 3 link与@import的区别 link是HTML方式， @import是CSS方式 link最大限度支持并行下载，@import过多嵌套导致串行下载，出现FOUC(文档样式短暂失效) link可以通过rel=&quot;alternate stylesheet&quot;指定候选样式 浏览器对link支持早于@import，可以使用@import对老浏览器隐藏样式 @import必须在样式规则之前，可以在css文件中引用其他文件 总体来说：link优于@import 4 什么是FOUC?如何避免 Flash Of Unstyled Content：用户定义样式表加载之前浏览器使用默认样式显示文档，用户样式加载渲染之后再从新显示文档，造成页面闪烁。 解决方法：把样式表放到文档的&lt;head&gt; 5 如何创建块级格式化上下文(block formatting context),BFC有什么用 BFC(Block Formatting Context)，块级格式化上下文，是一个独立的渲染区域，让处于 BFC 内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响 触发条件 (以下任意一条) float的值不为none overflow的值不为visible display的值为table-cell、tabble-caption和inline-block之一 position的值不为static或则releative中的任何一个 在IE下, Layout,可通过zoom:1 触发 .BFC布局与普通文档流布局区别 普通文档流布局: 浮动的元素是不会被父级计算高度 非浮动元素会覆盖浮动元素的位置 margin会传递给父级元素 两个相邻元素上下的margin会重叠 BFC布局规则: 浮动的元素会被父级计算高度(父级元素触发了BFC) 非浮动元素不会覆盖浮动元素的位置(非浮动元素触发了BFC) margin不会传递给父级(父级触发BFC) 属于同一个BFC的两个相邻元素上下margin会重叠 开发中的应用 阻止margin重叠 可以包含浮动元素 —— 清除内部浮动(清除浮动的原理是两个 div都位于同一个 BFC 区域之中) 自适应两栏布局 可以阻止元素被浮动元素覆盖 6 display、float、position的关系 如果display取值为none，那么position和float都不起作用，这种情况下元素不产生框 否则，如果position取值为absolute或者fixed，框就是绝对定位的，float的计算值为none，display根据下面的表格进行调整。 否则，如果float不是none，框是浮动的，display根据下表进行调整 否则，如果元素是根元素，display根据下表进行调整 其他情况下display的值为指定值 总结起来：绝对定位、浮动、根元素都需要调整display 7 清除浮动的几种方式，各自的优缺点 父级div定义height 结尾处加空div标签clear:both 父级div定义伪类:after和zoom 父级div定义overflow:hidden 父级div也浮动，需要定义宽度 结尾处加br标签clear:both 比较好的是第3种方式，好多网站都这么用 8 为什么要初始化CSS样式? 因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。 当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化 9 css3有哪些新特性 新增选择器 p:nth-child(n)&#123;color: rgba(255, 0, 0, 0.75)&#125; 弹性盒模型 display: flex; 多列布局 column-count: 5; 媒体查询 @media (max-width: 480px) &#123;.box: &#123;column-count: 1;&#125;&#125; 个性化字体 @font-face&#123;font-family: BorderWeb; src:url(BORDERW0.eot);&#125; 颜色透明度 color: rgba(255, 0, 0, 0.75); 圆角 border-radius: 5px; 渐变 background:linear-gradient(red, green, blue); 阴影 box-shadow:3px 3px 3px rgba(0, 64, 128, 0.3); 倒影 box-reflect: below 2px; 文字装饰 text-stroke-color: red; 文字溢出 text-overflow:ellipsis; 背景效果 background-size: 100px 100px; 边框效果 border-image:url(bt_blue.png) 0 10; 转换 旋转 transform: rotate(20deg); 倾斜 transform: skew(150deg, -10deg); 位移 transform: translate(20px, 20px); 缩放 transform: scale(.5); 平滑过渡 transition: all .3s ease-in .1s; 动画 @keyframes anim-1 &#123;50% &#123;border-radius: 50%;&#125;&#125; animation: anim-1 1s; CSS3新增伪类有那些？ p:first-of-type 选择属于其父元素的首个&lt;p&gt;元素的每个&lt;p&gt; 元素。 p:last-of-type 选择属于其父元素的最后 &lt;p&gt; 元素的每个&lt;p&gt; 元素。 p:only-of-type 选择属于其父元素唯一的 &lt;p&gt;元素的每个 &lt;p&gt; 元素。 p:only-child 选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。 p:nth-child(2) 选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。 :after 在元素之前添加内容,也可以用来做清除浮动。 :before 在元素之后添加内容。 :enabled 已启用的表单元素。 :disabled 已禁用的表单元素。 :checked 单选框或复选框被选中。 10 display有哪些值？说明他们的作用 block 转换成块状元素。 inline 转换成行内元素。 none 设置元素不可见。 inline-block 象行内元素一样显示，但其内容象块类型元素一样显示。 list-item 象块类型元素一样显示，并添加样式列表标记。 table 此元素会作为块级表格来显示 inherit 规定应该从父元素继承 display 属性的值 11 介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？ 有两种， IE盒子模型、W3C盒子模型； 盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)； 区 别： IE的content部分把 border 和 padding计算了进去; 盒子模型构成：内容(content)、内填充(padding)、 边框(border)、外边距(margin) IE8及其以下版本浏览器，未声明 DOCTYPE，内容宽高会包含内填充和边框，称为怪异盒模型(IE盒模型) 标准(W3C)盒模型：元素宽度 = width + padding + border + margin 怪异(IE)盒模型：元素宽度 = width + margin 标准浏览器通过设置 css3 的 box-sizing: border-box 属性，触发“怪异模式”解析计算宽高 box-sizing 常用的属性有哪些？分别有什么作用 box-sizing: content-box; 默认的标准(W3C)盒模型元素效果 box-sizing: border-box; 触发怪异(IE)盒模型元素的效果 box-sizing: inherit; 继承父元素 box-sizing 属性的值 12 CSS优先级算法如何计算？ 优先级就近原则，同权重情况下样式定义最近者为准 载入样式以最后载入的定位为准 优先级为: !important &gt; id &gt; class &gt; tag; !important 比 内联优先级高 13 对BFC规范的理解？ 一个页面是由很多个 Box 组成的,元素的类型和 display` 属性,决定了这个 Box 的类型 不同类型的 Box,会参与不同的 Formatting Context（决定如何渲染文档的容器）,因此Box内的元素会以不同的方式渲染,也就是说BFC内部的元素和外部的元素不会互相影响 14 谈谈浮动和清除浮动 浮动的框可以向左或向右移动，直到他的外边缘碰到包含框或另一个浮动框的边框为止。由于浮动框不在文档的普通流中，所以文档的普通流的块框表现得就像浮动框不存在一样。浮动的块框会漂浮在文档普通流的块框上 15 position的值， relative和absolute定位原点是 absolute：生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位 fixed：生成绝对定位的元素，相对于浏览器窗口进行定位 relative：生成相对定位的元素，相对于其正常位置进行定位 static 默认值。没有定位，元素出现在正常的流中 inherit 规定从父元素继承 position 属性的值 16 display:inline-block 什么时候不会显示间隙？(携程) 移除空格 使用margin负值 使用font-size:0 letter-spacing word-spacing 17 PNG\\GIF\\JPG的区别及如何选 GIF 8位像素，256色 无损压缩 支持简单动画 支持boolean透明 适合简单动画 JPEG 颜色限于256 有损压缩 可控制压缩质量 不支持透明 适合照片 PNG 有PNG8和truecolor PNG PNG8类似GIF颜色上限为256，文件小，支持alpha透明度，无动画 适合图标、背景、按钮 18 行内元素float:left后是否变为块级元素？ 行内元素设置成浮动之后变得更加像是inline-block（行内块级元素，设置成这个属性的元素会同时拥有行内和块级的特性，最明显的不同是它的默认宽度不是100%），这时候给行内元素设置padding-top和padding-bottom或者width、height都是有效果的 19 在网页中的应该使用奇数还是偶数的字体？为什么呢？ 偶数字号相对更容易和 web 设计的其他部分构成比例关系 20 ::before 和 :after中双冒号和单冒号 有什么区别？解释一下这2个伪元素的作用 单冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素 用于区分伪类和伪元素 21 如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里） 多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60*1000ms ＝ 16.7ms 22 CSS合并方法 避免使用@import引入多个css文件，可以使用CSS工具将CSS合并为一个CSS文件，例如使用Sass\\Compass等 23 CSS不同选择器的权重(CSS层叠的规则) ！important规则最重要，大于其它规则 行内样式规则，加1000 对于选择器中给定的各个ID属性值，加100 对于选择器中给定的各个类属性、属性选择器或者伪类选择器，加10 对于选择其中给定的各个元素标签选择器，加1 如果权值一样，则按照样式规则的先后顺序来应用，顺序靠后的覆盖靠前的规则 以下是权重的规则：标签的权重为1，class的权重为10，id的权重为100，以下/// 例子是演示各种定义的权重值： 1234567891011121314151617181920&#x2F;*权重为1*&#x2F;div&#123;&#125;&#x2F;*权重为10*&#x2F;.class1&#123;&#125;&#x2F;*权重为100*&#x2F;#id1&#123;&#125;&#x2F;*权重为100+1&#x3D;101*&#x2F;#id1 div&#123;&#125;&#x2F;*权重为10+1&#x3D;11*&#x2F;.class1 div&#123;&#125;&#x2F;*权重为10+10+1&#x3D;21*&#x2F;.class1 .class2 div&#123;&#125; 如果权重相同，则最后定义的样式会起作用，但是应该避免这种情况出现 24 列出你所知道可以改变页面布局的属性 position、display、float、width、height、margin、padding、top、left、right、` 25 CSS在性能优化方面的实践 css压缩与合并、Gzip压缩 css文件放在head里、不要用@import 尽量用缩写、避免用滤镜、合理使用选择器 26 CSS3动画（简单动画的实现，如旋转等） 依靠CSS3中提出的三个属性：transition、transform、animation transition：定义了元素在变化过程中是怎么样的，包含transition-property、transition-duration、transition-timing-function、transition-delay。 transform：定义元素的变化结果，包含rotate、scale、skew、translate。 animation：动画定义了动作的每一帧（@keyframes）有什么效果，包括animation-name，animation-duration、animation-timing-function、animation-delay、animation-iteration-count、animation-direction 27 base64的原理及优缺点 优点可以加密，减少了HTTTP请求 缺点是需要消耗CPU进行编解码 28 几种常见的CSS布局流体布局12345678910111213141516171819.left &#123; float: left; width: 100px; height: 200px; background: red;&#125;.right &#123; float: right; width: 200px; height: 200px; background: blue;&#125;.main &#123; margin-left: 120px; margin-right: 220px; height: 200px; background: green;&#125; 123456&lt;div class&#x3D;&quot;container&quot;&gt; &lt;div class&#x3D;&quot;left&quot;&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;right&quot;&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;main&quot;&gt;&lt;&#x2F;div&gt;&lt;&#x2F;div&gt; 圣杯布局 要求：三列布局；中间主体内容前置，且宽度自适应；两边内容定宽 好处：重要的内容放在文档流前面可以优先渲染 原理：利用相对定位、浮动、负边距布局，而不添加额外标签 1234567891011121314151617181920212223.container &#123; padding-left: 150px; padding-right: 190px;&#125;.main &#123; float: left; width: 100%;&#125;.left &#123; float: left; width: 190px; margin-left: -100%; position: relative; left: -150px;&#125;.right &#123; float: left; width: 190px; margin-left: -190px; position: relative; right: -190px;&#125; 123456&lt;div class&#x3D;&quot;container&quot;&gt; &lt;div class&#x3D;&quot;main&quot;&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;left&quot;&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;right&quot;&gt;&lt;&#x2F;div&gt;&lt;&#x2F;div&gt; 双飞翼布局 双飞翼布局：对圣杯布局（使用相对定位，对以后布局有局限性）的改进，消除相对定位布局 原理：主体元素上设置左右边距，预留两翼位置。左右两栏使用浮动和负边距归位，消除相对定位。 123456789101112131415161718192021222324252627.container &#123; &#x2F;*padding-left:150px;*&#x2F; &#x2F;*padding-right:190px;*&#x2F;&#125;.main-wrap &#123; width: 100%; float: left;&#125;.main &#123; margin-left: 150px; margin-right: 190px;&#125;.left &#123; float: left; width: 150px; margin-left: -100%; &#x2F;*position: relative;*&#x2F; &#x2F;*left:-150px;*&#x2F;&#125;.right &#123; float: left; width: 190px; margin-left: -190px; &#x2F;*position:relative;*&#x2F; &#x2F;*right:-190px;*&#x2F;&#125; 123456&lt;div class&#x3D;&quot;content&quot;&gt; &lt;div class&#x3D;&quot;main&quot;&gt;&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;div class&#x3D;&quot;left&quot;&gt;&lt;&#x2F;div&gt;&lt;div class&#x3D;&quot;right&quot;&gt;&lt;&#x2F;div&gt; 29 stylus/sass/less区别 均具有“变量”、“混合”、“嵌套”、“继承”、“颜色混合”五大基本特性 Scss和LESS语法较为严谨，LESS要求一定要使用大括号“{}”，Scss和Stylus可以通过缩进表示层次与嵌套关系 Scss无全局变量的概念，LESS和Stylus有类似于其它语言的作用域概念 Sass是基于Ruby语言的，而LESS和Stylus可以基于NodeJS NPM下载相应库后进行编译； 30 postcss的作用 可以直观的理解为：它就是一个平台。为什么说它是一个平台呢？因为我们直接用它，感觉不能干什么事情，但是如果让一些插件在它上面跑，那么将会很强大 PostCSS 提供了一个解析器，它能够将 CSS 解析成抽象语法树 通过在 PostCSS 这个平台上，我们能够开发一些插件，来处理我们的CSS，比如热门的：autoprefixer postcss可以对sass处理过后的css再处理 最常见的就是autoprefixer 31 css样式（选择器）的优先级 计算权重确定 !important 内联样式 后写的优先级高 32 自定义字体的使用场景 宣传/品牌/banner等固定文案 字体图标 33 如何美化CheckBox &lt;label&gt; 属性 for 和 id 隐藏原生的 &lt;input&gt; :checked + &lt;label&gt; 34 伪类和伪元素的区别 伪类表状态 伪元素是真的有元素 前者单冒号，后者双冒号 35 base64的使用 用于减少 HTTP 请求 适用于小图片 base64的体积约为原图的4/3 36 自适应布局思路： 左侧浮动或者绝对定位，然后右侧margin撑开 使用&lt;div&gt;包含，然后靠负margin形成bfc 使用flex 37 请用CSS写一个简单的幻灯片效果页面 知道是要用CSS3。使用animation动画实现一个简单的幻灯片效果 12345678910111213141516171819202122232425262728293031/**css**/.ani&#123; width:480px; height:320px; margin:50px auto; overflow: hidden; box-shadow:0 0 5px rgba(0,0,0,1); background-size: cover; background-position: center; -webkit-animation-name: &quot;loops&quot;; -webkit-animation-duration: 20s; -webkit-animation-iteration-count: infinite;&#125;@-webkit-keyframes &quot;loops&quot; &#123; 0% &#123; background:url(http://d.hiphotos.baidu.com/image/w%3D400/sign=c01e6adca964034f0fcdc3069fc27980/e824b899a9014c08e5e38ca4087b02087af4f4d3.jpg) no-repeat; &#125; 25% &#123; background:url(http://b.hiphotos.baidu.com/image/w%3D400/sign=edee1572e9f81a4c2632edc9e72b6029/30adcbef76094b364d72bceba1cc7cd98c109dd0.jpg) no-repeat; &#125; 50% &#123; background:url(http://b.hiphotos.baidu.com/image/w%3D400/sign=937dace2552c11dfded1be2353266255/d8f9d72a6059252d258e7605369b033b5bb5b912.jpg) no-repeat; &#125; 75% &#123; background:url(http://g.hiphotos.baidu.com/image/w%3D400/sign=7d37500b8544ebf86d71653fe9f9d736/0df431adcbef76095d61f0972cdda3cc7cd99e4b.jpg) no-repeat; &#125; 100% &#123; background:url(http://c.hiphotos.baidu.com/image/w%3D400/sign=cfb239ceb0fb43161a1f7b7a10a54642/3b87e950352ac65ce2e73f76f9f2b21192138ad1.jpg) no-repeat; &#125;&#125; 38 什么是外边距重叠？重叠的结果是什么？ 外边距重叠就是margin-collapse 在CSS当中，相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，并且因而所结合成的外边距称为折叠外边距。 折叠结果遵循下列计算规则： 两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。 两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。 两个外边距一正一负时，折叠结果是两者的相加的和。 39 rgba()和opacity的透明效果有什么不同？ rgba()和opacity都能实现透明效果，但最大的不同是opacity作用于元素，以及元素内的所有内容的透明度， 而rgba()只作用于元素的颜色或其背景色。（设置rgba透明的元素的子元素不会继承透明效果！） 40 css中可以让文字在垂直和水平方向上重叠的两个属性是什么？ 垂直方向：line-height 水平方向：letter-spacing 41 如何垂直居中一个浮动元素？123456789101112131415161718192021222324252627/**方法一：已知元素的高宽**/#div1&#123; background-color:#6699FF; width:200px; height:200px; position: absolute; //父元素需要相对定位 top: 50%; left: 50%; margin-top:-100px ; //二分之一的height，width margin-left: -100px;&#125;/**方法二:**/#div1&#123; width: 200px; height: 200px; background-color: #6699FF; margin:auto; position: absolute; //父元素需要相对定位 left: 0; top: 0; right: 0; bottom: 0;&#125; 如何垂直居中一个&lt;img&gt;?（用更简便的方法。） 123456#container /**&lt;img&gt;的容器设置如下**/&#123; display:table-cell; text-align:center; vertical-align:middle;&#125; 42 px和em的区别 px和em都是长度单位，区别是，px的值是固定的，指定是多少就是多少，计算比较容易。em得值不是固定的，并且em会继承父级元素的字体大小。 浏览器的默认字体高都是16px。所以未经调整的浏览器都符合: 1em=16px。那么12px=0.75em, 10px=0.625em。 px 相对于显示器屏幕分辨率，无法用浏览器字体放大功能 em 值并不是固定的，会继承父级的字体大小： em = 像素值 / 父级font-size 43 Sass、LESS是什么？大家为什么要使用他们？ 他们是CSS预处理器。他是CSS上的一种抽象层。他们是一种特殊的语法/语言编译成CSS。 例如Less是一种动态样式语言. 将CSS赋予了动态语言的特性，如变量，继承，运算， 函数. LESS 既可以在客户端上运行 (支持IE 6+, Webkit, Firefox)，也可一在服务端运行 (借助 Node.js) 为什么要使用它们？ 结构清晰，便于扩展。 可以方便地屏蔽浏览器私有语法差异。这个不用多说，封装对- 浏览器语法差异的重复处理，减少无意义的机械劳动。 可以轻松实现多重继承。 完全兼容 CSS 代码，可以方便地应用到老项目中。LESS 只- 是在 CSS 语法上做了扩展，所以老的 CSS 代码也可以与 LESS 代码一同编译 44 知道css有个content属性吗？有什么作用？有什么应用？ css的content属性专门应用在 before/after伪元素上，用于来插入生成内容。最常见的应用是利用伪类清除浮动。 1234567891011/**一种常见利用伪类清除浮动的代码**/.clearfix:after &#123; content:&quot;.&quot;; //这里利用到了content属性 display:block; height:0; visibility:hidden; clear:both; &#125;.clearfix &#123; *zoom:1;&#125; 45 水平居中的方法 元素为行内元素，设置父元素text-align:center 如果元素宽度固定，可以设置左右margin为auto; 绝对定位和移动: absolute + transform 使用flex-box布局，指定justify-content属性为center display设置为tabel-ceil 46 垂直居中的方法 将显示方式设置为表格，display:table-cell,同时设置vertial-align：middle 使用flex布局，设置为align-item：center 绝对定位中设置bottom:0,top:0,并设置margin:auto 绝对定位中固定高度时设置top:50%，margin-top值为高度一半的负值 文本垂直居中设置line-height为height值 如果是单行文本, line-height 设置成和 height 值 1234.vertical &#123; height: 100px; line-height: 100px; &#125; 已知高度的块级子元素，采用绝对定位和负边距 123456789.container &#123; position: relative;&#125;.vertical &#123; height: 300px; /*子元素高度*/ position: absolute; top:50%; /*父元素高度50%*/ margin-top: -150px; /*自身高度一半*/&#125; 未知高度的块级父子元素居中，模拟表格布局 缺点：IE67不兼容，父级 overflow：hidden 失效 1234567.container &#123; display: table; &#125; .content &#123; display: table-cell; vertical-align: middle; &#125; 新增 inline-block 兄弟元素，设置 vertical-align 缺点：需要增加额外标签，IE67不兼容 12345678910.container &#123; height: 100%;/*定义父级高度，作为参考*/&#125;.extra .vertical&#123; display: inline-block; /*行内块显示*/ vertical-align: middle; /*垂直居中*/&#125;.extra &#123; height: 100%; /*设置新增元素高度为100%*/&#125; 绝对定位配合 CSS3 位移 12345.vertical &#123; position: absolute; top:50%; /*父元素高度50%*/ transform:translateY(-50%, -50%);&#125; CSS3弹性盒模型 12345.container &#123; display:flex; justify-content: center; /*子元素水平居中*/ align-items: center; /*子元素垂直居中*/&#125; 47 如何使用CSS实现硬件加速？ 硬件加速是指通过创建独立的复合图层，让GPU来渲染这个图层，从而提高性能， 一般触发硬件加速的CSS属性有transform、opacity、filter，为了避免2D动画在 开始和结束的时候的repaint操作，一般使用tranform:translateZ(0) 48 重绘和回流（重排）是什么，如何避免？ 重绘：当渲染树中的元素外观（如：颜色）发生改变，不影响布局时，产生重绘 回流：当渲染树中的元素的布局（如：尺寸、位置、隐藏/状态状态）发生改变时，产生重绘回流 注意：JS获取Layout属性值（如：offsetLeft、scrollTop、getComputedStyle等）也会引起回流。因为浏览器需要通过回流计算最新值 回流必将引起重绘，而重绘不一定会引起回流 **如何最小化重绘(repaint)和回流(reflow)**： 需要要对元素进行复杂的操作时，可以先隐藏(display:&quot;none&quot;)，操作完成后再显示 需要创建多个DOM节点时，使用DocumentFragment创建完后一次性的加入document 缓存Layout属性值，如：var left = elem.offsetLeft; 这样，多次使用 left 只产生一次回流 尽量避免用table布局（table元素一旦触发回流就会导致table里所有的其它元素回流） 避免使用css表达式(expression)，因为每次调用都会重新计算值（包括加载页面） 尽量使用 css 属性简写，如：用 border 代替 border-width, border-style, border-color 批量修改元素样式：elem.className 和 elem.style.cssText 代替 elem.style.xxx 49 说一说css3的animation css3的animation是css3新增的动画属性，这个css3动画的每一帧是通过@keyframes来声明的，keyframes声明了动画的名称，通过from、to或者是百分比来定义 每一帧动画元素的状态，通过animation-name来引用这个动画，同时css3动画也可以定义动画运行的时长、动画开始时间、动画播放方向、动画循环次数、动画播放的方式， 这些相关的动画子属性有：animation-name定义动画名、animation-duration定义动画播放的时长、animation-delay定义动画延迟播放的时间、animation-direction定义 动画的播放方向、animation-iteration-count定义播放次数、animation-fill-mode定义动画播放之后的状态、animation-play-state定义播放状态，如暂停运行等、animation-timing-function 定义播放的方式，如恒速播放、艰涩播放等。 50 左边宽度固定，右边自适应 左侧固定宽度，右侧自适应宽度的两列布局实现 html结构 1234&lt;div class=&quot;outer&quot;&gt; &lt;div class=&quot;left&quot;&gt;固定宽度&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;自适应宽度&lt;/div&gt;&lt;/div&gt; 在外层div（类名为outer）的div中，有两个子div，类名分别为left和right，其中left为固定宽度，而right为自适应宽度 方法1：左侧div设置成浮动：float: left，右侧div宽度会自拉升适应 123456789101112131415.outer &#123; width: 100%; height: 500px; background-color: yellow;&#125;.left &#123; width: 200px; height: 200px; background-color: red; float: left;&#125;.right &#123; height: 200px; background-color: blue;&#125; 方法2：对右侧:div进行绝对定位，然后再设置right=0，即可以实现宽度自适应 绝对定位元素的第一个高级特性就是其具有自动伸缩的功能，当我们将 width设置为 auto 的时候（或者不设置，默认为 auto ），绝对定位元素会根据其 left 和 right 自动伸缩其大小 12345678910111213141516171819.outer &#123; width: 100%; height: 500px; background-color: yellow; position: relative;&#125;.left &#123; width: 200px; height: 200px; background-color: red;&#125;.right &#123; height: 200px; background-color: blue; position: absolute; left: 200px; top:0; right: 0;&#125; 方法3：将左侧div进行绝对定位，然后右侧div设置margin-left: 200px 1234567891011121314151617.outer &#123; width: 100%; height: 500px; background-color: yellow; position: relative;&#125;.left &#123; width: 200px; height: 200px; background-color: red; position: absolute;&#125;.right &#123; height: 200px; background-color: blue; margin-left: 200px;&#125; 方法4：使用flex布局 1234567891011121314151617.outer &#123; width: 100%; height: 500px; background-color: yellow; display: flex; flex-direction: row;&#125;.left &#123; width: 200px; height: 200px; background-color: red;&#125;.right &#123; height: 200px; background-color: blue; flex: 1;&#125; 51 两种以上方式实现已知或者未知宽度的垂直水平居中123456789101112131415161718192021222324252627282930313233343536373839404142/** 1 **/.wraper &#123; position: relative; .box &#123; position: absolute; top: 50%; left: 50%; width: 100px; height: 100px; margin: -50px 0 0 -50px; &#125;&#125;/** 2 **/.wraper &#123; position: relative; .box &#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); &#125;&#125;/** 3 **/.wraper &#123; .box &#123; display: flex; justify-content:center; align-items: center; height: 100px; &#125;&#125;/** 4 **/.wraper &#123; display: table; .box &#123; display: table-cell; vertical-align: middle; &#125;&#125; 52 如何实现小于12px的字体效果 transform:scale()这个属性只可以缩放可以定义宽高的元素，而行内元素是没有宽高的，我们可以加上一个display:inline-block; 1transform: scale(0.7); css的属性，可以缩放大小 53 css hack原理及常用hack 原理：利用不同浏览器对CSS的支持和解析结果不一样编写针对特定浏览器样式。 常见的hack有 属性hack 选择器hack IE条件注释 54 CSS有哪些继承属性 关于文字排版的属性如： font word-break letter-spacing text-align text-rendering word-spacing white-space text-indent text-transform text-shadow line-height color visibility cursor 55 外边距折叠(collapsing margins) 毗邻的两个或多个 margin 会合并成一个margin，叫做外边距折叠。规则如下： 两个或多个毗邻的普通流中的块元素垂直方向上的margin会折叠 浮动元素或inline-block元素或绝对定位元素的margin不会和垂直方向上的其他元素的margin折叠 创建了块级格式化上下文的元素，不会和它的子元素发生margin折叠 元素自身的margin-bottom和margin-top相邻时也会折 56 CSS选择符有哪些？哪些属性可以继承 id选择器（ # myid） 类选择器（.myclassname） 标签选择器（div, h1, p） 相邻选择器（h1 + p） 子选择器（ul &gt; li） 后代选择器（li a） 通配符选择器（ * ） 属性选择器（a[rel = &quot;external&quot;]） 伪类选择器（a:hover, li:nth-child） CSS哪些属性可以继承？哪些属性不可以继承 可继承的样式： font-size font-family color, UL LI DL DD DT 不可继承的样式：border padding margin width height 57 CSS3新增伪类有那些 :root 选择文档的根元素，等同于 html 元素 :empty 选择没有子元素的元素 :target 选取当前活动的目标元素 :not(selector) 选择除 selector 元素意外的元素 :enabled 选择可用的表单元素 :disabled 选择禁用的表单元素 :checked 选择被选中的表单元素 :after 在元素内部最前添加内容 :before 在元素内部最后添加内容 :nth-child(n) 匹配父元素下指定子元素，在所有子元素中排序第n :nth-last-child(n) 匹配父元素下指定子元素，在所有子元素中排序第n，从后向前数 :nth-child(odd) :nth-child(even) :nth-child(3n+1) :first-child :last-child :only-child :nth-of-type(n) 匹配父元素下指定子元素，在同类子元素中排序第n :nth-last-of-type(n) 匹配父元素下指定子元素，在同类子元素中排序第n，从后向前数 :nth-of-type(odd) :nth-of-type(even) :nth-of-type(3n+1) :first-of-type :last-of-type :only-of-type ::selection 选择被用户选取的元素部分 :first-line 选择元素中的第一行 :first-letter 选择元素中的第一个字符 58 如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中 给div设置一个宽度，然后添加margin:0 auto属性 1234div&#123; width:200px; margin:0 auto;&#125; 居中一个浮动元素 1234567891011/* 确定容器的宽高 宽500 高 300 的层设置层的外边距 */.div &#123; width:500px ; height:300px;//高度可以不设 margin: -150px 0 0 -250px; position:relative; //相对定位 background-color:pink; //方便看效果 left:50%; top:50%;&#125; 让绝对定位的div居中 12345678position: absolute;width: 1200px;background: none;margin: 0 auto;top: 0;left: 0;bottom: 0;right: 0; 59 用纯CSS创建一个三角形的原理是什么123456789&#x2F;* 把上、左、右三条边隐藏掉（颜色设为 transparent） *&#x2F;#demo &#123; width: 0; height: 0; border-width: 20px; border-style: solid; border-color: transparent transparent red transparent;&#125; 60 一个满屏 品 字布局 如何设计? 简单的方式： 上面的div宽100%， 下面的两个div分别宽50%， 然后用float或者inline使其不换行即可 61 li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法 行框的排列会受到中间空白（回车\\空格）等的影响，因为空格也属于字符,这些空白也会被应用样式，占据空间，所以会有间隔，把字符大小设为0，就没有空格了 62 为什么要初始化CSS样式 因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异 63 请列举几种隐藏元素的方法 visibility: hidden; 这个属性只是简单的隐藏某个元素，但是元素占用的空间任然存在 opacity: 0; CSS3属性，设置0可以使一个元素完全透明 position: absolute; 设置一个很大的 left 负值定位，使元素定位在可见区域之外 display: none; 元素会变得不可见，并且不会再占用文档的空间。 transform: scale(0); 将一个元素设置为缩放无限小，元素将不可见，元素原来所在的位置将被保留 &lt;div hidden=&quot;hidden&quot;&gt; HTML5属性,效果和display:none;相同，但这个属性用于记录一个元素的状态 height: 0; 将元素高度设为 0 ，并消除边框 filter: blur(0); CSS3属性，将一个元素的模糊度设置为0，从而使这个元素“消失”在页面中 64 rgba() 和 opacity 的透明效果有什么不同 opacity 作用于元素以及元素内的所有内容（包括文字）的透明度 rgba() 只作用于元素自身的颜色或其背景色，子元素不会继承透明效果 65 css 属性 content 有什么作用 content 属性专门应用在 before/after 伪元素上，用于插入额外内容或样式 66 请解释一下 CSS3 的 Flexbox（弹性盒布局模型）以及适用场景 1Flexbox1 用于不同尺寸屏幕中创建可自动扩展和收缩布局 67 经常遇到的浏览器的JS兼容性有哪些？解决方法是什么 当前样式：getComputedStyle(el, null) VS el.currentStyle 事件对象：e VS window.event 鼠标坐标：e.pageX, e.pageY VS window.event.x, window.event.y 按键码：e.which VS event.keyCode 文本节点：el.textContent VS el.innerText 68 请写出多种等高布局 在列的父元素上使用这个背景图进行Y轴的铺放，从而实现一种等高列的假像 模仿表格布局等高列效果：兼容性不好，在ie6-7无法正常运行 css3 flexbox 布局： .container{display: flex; align-items: stretch;} 69 浮动元素引起的问题 父元素的高度无法被撑开，影响与父元素同级的元素 与浮动元素同级的非浮动元素会跟随其后 70 CSS优化、提高性能的方法有哪些 多个css合并，尽量减少HTTP请求 将css文件放在页面最上面 移除空的css规则 避免使用CSS表达式 选择器优化嵌套，尽量避免层级过深 充分利用css继承属性，减少代码量 抽象提取公共样式，减少代码量 属性值为0时，不加单位 属性值为小于1的小数时，省略小数点前面的0 css雪碧图 71 浏览器是怎样解析CSS选择器的 浏览器解析 CSS 选择器的方式是从右到左 72 在网页中的应该使用奇数还是偶数的字体 在网页中的应该使用“偶数”字体： 偶数字号相对更容易和 web 设计的其他部分构成比例关系 使用奇数号字体时文本段落无法对齐 宋体的中文网页排布中使用最多的就是 12 和 14 73 margin和padding分别适合什么场景使用 需要在border外侧添加空白，且空白处不需要背景（色）时，使用 margin 需要在border内测添加空白，且空白处需要背景（色）时，使用 padding 74 抽离样式模块怎么写，说出思路 CSS可以拆分成2部分：公共CSS 和 业务CSS： 网站的配色，字体，交互提取出为公共CSS。这部分CSS命名不应涉及具体的业务 对于业务CSS，需要有统一的命名，使用公用的前缀。可以参考面向对象的CSS 75 元素竖向的百分比设定是相对于容器的高度吗 元素竖向的百分比设定是相对于容器的宽度，而不是高度 76 全屏滚动的原理是什么？ 用到了CSS的那些属性 原理类似图片轮播原理，超出隐藏部分，滚动时显示 可能用到的CSS属性：overflow:hidden; transform:translate(100%, 100%); display:none; 77 什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE 响应式设计就是网站能够兼容多个终端，而不是为每个终端做一个特定的版本 基本原理是利用CSS3媒体查询，为不同尺寸的设备适配不同样式 对于低版本的IE，可采用JS获取屏幕宽度，然后通过resize方法来实现兼容： 12345678910111213141516$(window).resize(function () &#123; screenRespond();&#125;);screenRespond();function screenRespond()&#123;var screenWidth = $(window).width();if(screenWidth &lt;= 1800)&#123; $(&quot;body&quot;).attr(&quot;class&quot;, &quot;w1800&quot;);&#125;if(screenWidth &lt;= 1400)&#123; $(&quot;body&quot;).attr(&quot;class&quot;, &quot;w1400&quot;);&#125;if(screenWidth &gt; 1800)&#123; $(&quot;body&quot;).attr(&quot;class&quot;, &quot;&quot;);&#125;&#125; 78 什么是视差滚动效果，如何给每页做不同的动画 视差滚动是指多层背景以不同的速度移动，形成立体的运动效果，具有非常出色的视觉体验 一般把网页解剖为：背景层、内容层和悬浮层。当滚动鼠标滚轮时，各图层以不同速度移动，形成视差的 实现原理 以 “页面滚动条” 作为 “视差动画进度条” 以 “滚轮刻度” 当作 “动画帧度” 去播放动画的 监听 mousewheel 事件，事件被触发即播放动画，实现“翻页”效果 79 a标签上四个伪类的执行顺序是怎么样的 link &gt; visited &gt; hover &gt; active L-V-H-A love hate 用喜欢和讨厌两个词来方便记忆 80 伪元素和伪类的区别和作用 伪元素 – 在内容元素的前后插入额外的元素或样式，但是这些元素实际上并不在文档中生成。 它们只在外部显示可见，但不会在文档的源代码中找到它们，因此，称为“伪”元素。例如： 1234p::before &#123;content:&quot;第一章：&quot;;&#125;p::after &#123;content:&quot;Hot!&quot;;&#125;p::first-line &#123;background:red;&#125;p::first-letter &#123;font-size:30px;&#125; 伪类 – 将特殊的效果添加到特定选择器上。它是已有元素上添加类别的，不会产生新的元素。例如： 12a:hover &#123;color: #FF00FF&#125;p:first-child &#123;color: red&#125; 81 ::before 和 :after 中双冒号和单冒号有什么区别 在 CSS 中伪类一直用 : 表示，如 :hover, :active 等 伪元素在CSS1中已存在，当时语法是用 : 表示，如 :before 和 :after 后来在CSS3中修订，伪元素用 :: 表示，如 ::before 和 ::after，以此区分伪元素和伪类 由于低版本IE对双冒号不兼容，开发者为了兼容性各浏览器，继续使使用 :after 这种老语法表示伪元素 综上所述：::before 是 CSS3 中写伪元素的新语法； :after 是 CSS1 中存在的、兼容IE的老语法 82 如何修改Chrome记住密码后自动填充表单的黄色背景 产生原因：由于Chrome默认会给自动填充的input表单加上 input:-webkit-autofill 私有属性造成的 解决方案1：在form标签上直接关闭了表单的自动填充：autocomplete=&quot;off&quot; 解决方案2：input:-webkit-autofill &#123; background-color: transparent; &#125; input [type=search] 搜索框右侧小图标如何美化？ 12345678input[type=&quot;search&quot;]::-webkit-search-cancel-button&#123; -webkit-appearance: none; height: 15px; width: 15px; border-radius: 8px; background:url(&quot;images/searchicon.png&quot;) no-repeat 0 0; background-size: 15px 15px;&#125; 83 网站图片文件，如何点击下载？而非点击预览&lt;a href=&quot;logo.jpg&quot; download&gt;下载&lt;/a&gt; &lt;a href=&quot;logo.jpg&quot; download=&quot;网站LOGO&quot; &gt;下载&lt;/a&gt; 63 iOS safari 如何阻止“橡皮筋效果”1234567$(document).ready(function()&#123; var stopScrolling = function(event) &#123; event.preventDefault(); &#125; document.addEventListener(&#x27;touchstart&#x27;, stopScrolling, false); document.addEventListener(&#x27;touchmove&#x27;, stopScrolling, false);&#125;); 84 你对 line-height 是如何理解的 line-height 指一行字的高度，包含了字间距，实际上是下一行基线到上一行基线距离 如果一个标签没有定义 height 属性，那么其最终表现的高度是由 line-height 决定的 一个容器没有设置高度，那么撑开容器高度的是 line-height 而不是容器内的文字内容 把 line-height 值设置为 height 一样大小的值可以实现单行文字的垂直居中 line-height 和 height 都能撑开一个高度，height 会触发 haslayout，而 line-height 不会 85 line-height 三种赋值方式有何区别？（带单位、纯数字、百分比） 带单位：px 是固定值，而 em 会参考父元素 font-size 值计算自身的行高 纯数字：会把比例传递给后代。例如，父级行高为 1.5，子元素字体为 18px，则子元素行高为 1.5 * 18 = 27px 百分比：将计算后的值传递给后代 86 设置元素浮动后，该元素的 display 值会如何变化 设置元素浮动后，该元素的 display 值自动变成 block 87 让页面里的字体变清晰，变细用CSS怎么做？（IOS手机浏览器字体齿轮设置）1-webkit-font-smoothing: antialiased; 88 font-style 属性 oblique 是什么意思 font-style: oblique; 使没有 italic 属性的文字实现倾斜 89 display:inline-block 什么时候会显示间隙 相邻的 inline-block 元素之间有换行或空格分隔的情况下会产生间距 非 inline-block 水平元素设置为 inline-block 也会有水平间距 可以借助 vertical-align:top; 消除垂直间隙 可以在父级加 font-size：0; 在子元素里设置需要的字体大小，消除垂直间隙 把 li 标签写到同一行可以消除垂直间隙，但代码可读性差 90 一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度 方案1： .sub &#123; height: calc(100%-100px); &#125; 方案2： .container &#123; position:relative; &#125; .sub &#123; position: absolute; top: 100px; bottom: 0; &#125; 方案3： .container &#123; display:flex; flex-direction:column; &#125; .sub &#123; flex:1; &#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://miren521.gihub.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"基础","slug":"前端/基础","permalink":"https://miren521.gihub.io/categories/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://miren521.gihub.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://miren521.gihub.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"分享","slug":"分享","permalink":"https://miren521.gihub.io/tags/%E5%88%86%E4%BA%AB/"},{"name":"基础","slug":"基础","permalink":"https://miren521.gihub.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"HTML、HTTP","slug":"HTML、HTTP","permalink":"https://miren521.gihub.io/tags/HTML%E3%80%81HTTP/"}]},{"title":"前端指南-HTML、HTTP、web综合问题","slug":"前端/学习指南/基础篇/HTML、HTTP、web综合问题","date":"2021-06-02T03:14:14.000Z","updated":"2021-07-10T12:13:04.814Z","comments":true,"path":"ckycsfmmo003am0wfc661g0gf/","link":"","permalink":"https://miren521.gihub.io/ckycsfmmo003am0wfc661g0gf/","excerpt":"这是对于前端-HTML、HTTP、web综合问题的学习笔记及分享，会一直更新，保持学习的进步","text":"这是对于前端-HTML、HTTP、web综合问题的学习笔记及分享，会一直更新，保持学习的进步 1 前端需要注意哪些SEO 合理的title、description、keywords：搜索对着三项的权重逐个减小，title值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面title要有所不同；description把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面description有所不同；keywords列举出重要关键词即可 语义化的HTML代码，符合W3C规范：语义化代码让搜索引擎容易理解网页 重要内容HTML代码放在最前：搜索引擎抓取HTML顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取 重要内容不要用js输出：爬虫不会执行js获取内容 少用iframe：搜索引擎不会抓取iframe中的内容 非装饰性图片必须加alt 提高网站速度：网站速度是搜索引擎排序的一个重要指标 2 如何进行网站性能优化 content方面 减少HTTP请求：合并文件、CSS精灵、inline Image 减少DNS查询：DNS缓存、将资源分布到恰当数量的主机名 减少DOM元素数量 Server方面 使用CDN 配置ETag 对组件使用Gzip压缩 Cookie方面 减小cookie大小 css方面 将样式表放到页面顶部 不使用CSS表达式 使用&lt;link&gt;不使用@import Javascript方面 将脚本放到页面底部 将javascript和css从外部引入 压缩javascript和css 删除不需要的脚本 减少DOM访问 图片方面 优化图片：根据实际颜色需要选择色深、压缩 优化css精灵 不要在HTML中拉伸图片 你有用过哪些前端性能优化的方法？ 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。 当需要设置的样式很多时设置className而不是直接操作style 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性) 图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳 避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢 谈谈性能优化问题 代码层面：避免使用css表达式，避免使用高级选择器，通配选择器 缓存利用：缓存Ajax，使用CDN，使用外部js和css文件以便缓存，添加Expires头，服务端配置Etag，减少DNS查找等 请求数量：合并样式和脚本，使用css图片精灵，初始首屏之外的图片资源按需加载，静态资源延迟加载 请求带宽：压缩文件，开启GZIP 前端性能优化最佳实践？ 性能评级工具（PageSpeed 或 YSlow） 合理设置 HTTP 缓存：Expires 与 Cache-control 静态资源打包，开启 Gzip 压缩（节省响应流量） CSS3 模拟图像，图标base64（降低请求数） 模块延迟(defer)加载/异步(async)加载 Cookie 隔离（节省请求流量） localStorage（本地存储） 使用 CDN 加速（访问最近服务器） 启用 HTTP/2（多路复用，并行加载） 前端自动化（gulp/webpack） 3 HTTP状态码及其含义 1XX：信息状态码 100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息 2XX：成功状态码 200 OK 正常返回信息 201 Created 请求成功并且服务器创建了新的资源 202 Accepted 服务器已接受请求，但尚未处理 3XX：重定向 301 Moved Permanently 请求的网页已永久移动到新位置。 302 Found 临时性重定向。 303 See Other 临时性重定向，且总是使用 GET 请求新的 URI。 304 Not Modified 自从上次请求后，请求的网页未修改过。 4XX：客户端错误 400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。 401 Unauthorized 请求未授权。 403 Forbidden 禁止访问。 404 Not Found 找不到如何与 URI 相匹配的资源。 5XX: 服务器错误 500 Internal Server Error 最常见的服务器端错误。 503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。 4 语义化的理解 用正确的标签做正确的事情！ HTML语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析； 在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的。 搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重，利于 SEO。 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解 5 介绍一下你对浏览器内核的理解？ 主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎 渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核 JS引擎则：解析和执行javascript来实现网页的动态效果 最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎 常见的浏览器内核有哪些 Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML] Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等 Presto内核：Opera7及以上。 [Opera内核原为：Presto，现为：Blink;] Webkit内核：Safari,Chrome等。 [ Chrome的Blink（WebKit的分支）] 6 html5有哪些新特性、移除了那些元素？ HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加 新增选择器 document.querySelector、document.querySelectorAll 拖拽释放(Drag and drop) API 媒体播放的 video 和 audio 本地存储 localStorage 和 sessionStorage 离线应用 manifest 桌面通知 Notifications 语意化标签 article、footer、header、nav、section 增强表单控件 calendar、date、time、email、url、search 地理位置 Geolocation 多任务 webworker 全双工通信协议 websocket 历史管理 history 跨域资源共享(CORS) Access-Control-Allow-Origin 页面可见性改变事件 visibilitychange 跨窗口通信 PostMessage Form Data 对象 绘画 canvas 移除的元素： 纯表现的元素：basefont、big、center、font、 s、strike、tt、u 对可用性产生负面影响的元素：frame、frameset、noframes 支持HTML5新标签： IE8/IE7/IE6支持通过document.createElement方法产生的标签 可以利用这一特性让这些浏览器支持HTML5新标签 浏览器支持新标签后，还需要添加标签默认的样式 当然也可以直接使用成熟的框架、比如html5shim 如何区分 HTML 和 HTML5 DOCTYPE声明、新增的结构元素、功能元素 7 HTML5的离线储存怎么使用，工作原理能不能解释一下？ 在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件 原理：HTML5的离线存储是基于一个新建的.appcache文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示 如何使用： 页面头部像下面一样加入一个manifest的属性； 在cache.manifest文件的编写离线存储的资源 在离线状态时，操作window.applicationCache进行需求实现 123456789CACHE MANIFEST#v0.11CACHE:js/app.jscss/style.cssNETWORK:resourse/logo.pngFALLBACK:/offline.html 8 浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢 在线的情况下，浏览器发现html头部有manifest属性，它会请求manifest文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。 离线的情况下，浏览器就直接使用离线存储的资源。 9 请描述一下 cookies，sessionStorage 和 localStorage 的区别？ cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密） cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递 sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存 存储大小： cookie数据大小不能超过4k sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大 有期时间： localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据 sessionStorage 数据在当前浏览器窗口关闭后自动删除 cookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭 10 iframe有那些缺点？ iframe会阻塞主页面的Onload事件 搜索引擎的检索程序无法解读这种页面，不利于SEO iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载 使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript动态给iframe添加src属性值，这样可以绕开以上两个问题 11 xhtml和html有什么区别? 一个是功能上的差别 主要是XHTML可兼容各大浏览器、手机以及PDA，并且浏览器也能快速正确地编译网页 另外是书写习惯的差别 XHTML 元素必须被正确地嵌套，闭合，区分大小写，文档必须拥有根元素 12 Canvas和SVG有什么区别？ svg绘制出来的每一个图形的元素都是独立的DOM节点，能够方便的绑定事件或用来修改。canvas输出的是一整幅画布 svg输出的图形是矢量图形，后期可以修改参数来自由放大缩小，不会失真和锯齿。而canvas输出标量画布，就像一张图片一样，放大会失真或者锯齿 13 viewport123456789&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot; /&gt; // width 设置viewport宽度，为一个正整数，或字符串‘device-width’ // device-width 设备宽度 // height 设置viewport高度，一般设置了宽度，会自动解析出高度，可以不用设置 // initial-scale 默认缩放比例（初始缩放比例），为一个数字，可以带小数 // minimum-scale 允许用户最小缩放比例，为一个数字，可以带小数 // maximum-scale 允许用户最大缩放比例，为一个数字，可以带小数 // user-scalable 是否允许手动缩放 延伸提问 怎样处理 移动端 1px 被 渲染成 2px问题 局部处理 meta标签中的 viewport属性 ，initial-scale 设置为 1 rem按照设计稿标准走，外加利用transfrome 的scale(0.5) 缩小一倍即可； 全局处理 mate标签中的 viewport属性 ，initial-scale 设置为 0.5 rem 按照设计稿标准走即可 14 渲染优化 禁止使用iframe（阻塞父文档onload事件） iframe会阻塞主页面的Onload事件 搜索引擎的检索程序无法解读这种页面，不利于SEO iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载 使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript 动态给iframe添加src属性值，这样可以绕开以上两个问题 禁止使用gif图片实现loading效果（降低CPU消耗，提升渲染性能） 使用CSS3代码代替JS动画（尽可能避免重绘重排以及回流） 对于一些小图标，可以使用base64位编码，以减少网络请求。但不建议大图使用，比较耗费CPU 小图标优势在于 减少HTTP请求 避免文件跨域 修改及时生效 页面头部的&lt;style&gt;&lt;/style&gt; &lt;script&gt;&lt;/script&gt; 会阻塞页面；（因为 Renderer进程中 JS线程和渲染线程是互斥的） 页面中空的 href 和 src 会阻塞页面其他资源的加载 (阻塞下载进程) 网页gzip，CDN托管，data缓存 ，图片服务器 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能 当需要设置的样式很多时设置className而不是直接操作style 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作 图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳 对普通的网站有一个统一的思路，就是尽量向前端优化、减少数据库操作、减少磁盘IO 15 meta viewport相关123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt; &lt;!--H5标准声明，使用 HTML5 doctype，不区分大小写--&gt;&lt;head lang=”en”&gt; &lt;!--标准的 lang 属性写法--&gt;&lt;meta charset=’utf-8′&gt; &lt;!--声明文档使用的字符编码--&gt;&lt;meta http-equiv=”X-UA-Compatible” content=”IE=edge,chrome=1″/&gt; &lt;!--优先使用 IE 最新版本和 Chrome--&gt;&lt;meta name=”description” content=”不超过150个字符”/&gt; &lt;!--页面描述--&gt;&lt;meta name=”keywords” content=””/&gt; &lt;!-- 页面关键词--&gt;&lt;meta name=”author” content=”name, email@gmail.com”/&gt; &lt;!--网页作者--&gt;&lt;meta name=”robots” content=”index,follow”/&gt; &lt;!--搜索引擎抓取--&gt;&lt;meta name=”viewport” content=”initial-scale=1, maximum-scale=3, minimum-scale=1, user-scalable=no”&gt; &lt;!--为移动设备添加 viewport--&gt;&lt;meta name=”apple-mobile-web-app-title” content=”标题”&gt; &lt;!--iOS 设备 begin--&gt;&lt;meta name=”apple-mobile-web-app-capable” content=”yes”/&gt; &lt;!--添加到主屏后的标题（iOS 6 新增）是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏--&gt;&lt;meta name=”apple-itunes-app” content=”app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL”&gt;&lt;!--添加智能 App 广告条 Smart App Banner（iOS 6+ Safari）--&gt;&lt;meta name=”apple-mobile-web-app-status-bar-style” content=”black”/&gt;&lt;meta name=”format-detection” content=”telphone=no, email=no”/&gt; &lt;!--设置苹果工具栏颜色--&gt;&lt;meta name=”renderer” content=”webkit”&gt; &lt;!-- 启用360浏览器的极速模式(webkit)--&gt;&lt;meta http-equiv=”X-UA-Compatible” content=”IE=edge”&gt; &lt;!--避免IE使用兼容模式--&gt;&lt;meta http-equiv=”Cache-Control” content=”no-siteapp” /&gt; &lt;!--不让百度转码--&gt;&lt;meta name=”HandheldFriendly” content=”true”&gt; &lt;!--针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓--&gt;&lt;meta name=”MobileOptimized” content=”320″&gt; &lt;!--微软的老式浏览器--&gt;&lt;meta name=”screen-orientation” content=”portrait”&gt; &lt;!--uc强制竖屏--&gt;&lt;meta name=”x5-orientation” content=”portrait”&gt; &lt;!--QQ强制竖屏--&gt;&lt;meta name=”full-screen” content=”yes”&gt; &lt;!--UC强制全屏--&gt;&lt;meta name=”x5-fullscreen” content=”true”&gt; &lt;!--QQ强制全屏--&gt;&lt;meta name=”browsermode” content=”application”&gt; &lt;!--UC应用模式--&gt;&lt;meta name=”x5-page-mode” content=”app”&gt; &lt;!-- QQ应用模式--&gt;&lt;meta name=”msapplication-tap-highlight” content=”no”&gt; &lt;!--windows phone 点击无高亮设置页面不缓存--&gt;&lt;meta http-equiv=”pragma” content=”no-cache”&gt;&lt;meta http-equiv=”cache-control” content=”no-cache”&gt;&lt;meta http-equiv=”expires” content=”0″&gt; 16 你做的页面在哪些流览器测试过？这些浏览器的内核分别是什么? IE: trident内核 Firefox：gecko内核 Safari:webkit内核 Opera:以前是presto内核，Opera现已改用Google - Chrome的Blink内核 Chrome:Blink(基于webkit，Google与Opera Software共同开发) 17 div+css的布局较table布局有什么优点？ 改版的时候更方便 只要改css文件。 页面加载速度更快、结构化清晰、页面显示简洁。 表现与结构相分离。 易于优化（seo）搜索引擎更友好，排名更容易靠前。 18 你能描述一下渐进增强和优雅降级之间的不同吗 渐进增强：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。 优雅降级：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。 区别：优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要。降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带 19 为什么利用多个域名来存储网站资源会更有效？ CDN缓存更方便 突破浏览器并发限制 节约cookie带宽 节约主域名的连接数，优化页面响应速度 防止不必要的安全问题 20 简述一下src与href的区别 src用于替换当前元素，href用于在当前文档和引用资源之间确立联系。 src是source的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求src资源时会将其指向的资源下载并应用到文档内，例如js脚本，img图片和frame等元素 &lt;script src =&quot;js.js&quot;&gt;&lt;/script&gt; 当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部 href是Hypertext Reference的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，如果我们在文档中添加 &lt;link href=&quot;common.css&quot; rel=&quot;stylesheet&quot;/&gt;那么浏览器会识别该文档为css文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用link方式来加载css，而不是使用@import方式 21 知道的网页制作会用到的图片格式有哪些？ png-8、png-24、jpeg、gif、svg 但是上面的那些都不是面试官想要的最后答案。面试官希望听到是Webp,Apng。（是否有关注新技术，新鲜事物） Webp：WebP格式，谷歌（google）开发的一种旨在加快图片加载速度的图片格式。图片压缩体积大约只有JPEG的2/3，并能节省大量的服务器带宽资源和数据空间。Facebook Ebay等知名网站已经开始测试并使用WebP格式。 在质量相同的情况下，WebP格式图像的体积要比JPEG格式图像小40%。 Apng：全称是“Animated Portable Network Graphics”, 是PNG的位图动画扩展，可以实现png格式的动态图片效果。04年诞生，但一直得不到各大浏览器厂商的支持，直到日前得到 iOS safari 8的支持，有望代替GIF成为下一代动态图标准 22 在css/js代码上线之后开发人员经常会优化性能，从用户刷新网页开始，一次js请求一般情况下有哪些地方会有缓存处理？ dns缓存，cdn缓存，浏览器缓存，服务器缓存 23 一个页面上有大量的图片（大型电商网站），加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验。 图片懒加载，在页面上的未可视区域可以添加一个滚动事件，判断图片位置与浏览器顶端的距离与页面的距离，如果前者小于后者，优先加载。 如果为幻灯片、相册等，可以使用图片预加载技术，将当前展示图片的前一张和后一张优先下载。 如果图片为css图片，可以使用CSSsprite，SVGsprite，Iconfont、Base64等技术。 如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。 如果图片展示区域小于图片的真实大小，则因在服务器端根据业务需要先行进行图片压缩，图片压缩后大小与展示一致。 24 请你谈谈Cookie的弊端 cookie虽然在持久保存客户端数据提供了方便，分担了服务器存储的负担，但还是有很多局限性的 每个特定的域名下最多生成20个cookie IE6或更低版本最多20个cookie IE7和之后的版本最后可以有50个cookie Firefox最多50个cookie chrome和Safari没有做硬性限制 IE 和 Opera 会清理近期最少使用的 cookie，Firefox 会随机清理 cookie cookie 的最大大约为 4096 字节，为了兼容性，一般设置不超过 4095 字节 如果 cookie 被人拦截了，就可以取得所有的 session 信息 25 git fetch和git pull的区别 git pull：相当于是从远程获取最新版本并merge到本地 git fetch：相当于是从远程获取最新版本到本地，不会自动merge","categories":[{"name":"前端","slug":"前端","permalink":"https://miren521.gihub.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"基础","slug":"前端/基础","permalink":"https://miren521.gihub.io/categories/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://miren521.gihub.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"基础","slug":"基础","permalink":"https://miren521.gihub.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"HTML、HTTP","slug":"HTML、HTTP","permalink":"https://miren521.gihub.io/tags/HTML%E3%80%81HTTP/"}]},{"title":"tp学习笔记","slug":"php/thinkphp/tp学习笔记","date":"2020-09-25T13:03:14.000Z","updated":"2021-07-10T12:13:04.800Z","comments":true,"path":"ckycsfmmi002qm0wf3989gj9s/","link":"","permalink":"https://miren521.gihub.io/ckycsfmmi002qm0wf3989gj9s/","excerpt":"这是对于tp的学习笔记及分享，会一直更新，保持学习的进步","text":"这是对于tp的学习笔记及分享，会一直更新，保持学习的进步 tp5tp6index方法123456789101112131415161718if (Request::isPost()) &#123; $keys = $this-&gt;request-&gt;post(&#x27;keys&#x27;, &#x27;&#x27;, &#x27;trim&#x27;); $where = []; if ($keys != &#x27;&#x27;) &#123; $where[] = [&#x27;title&#x27;, &#x27;like&#x27;, &#x27;%&#x27; . $keys . &#x27;%&#x27;]; &#125; $page = $this-&gt;request-&gt;post(&#x27;page&#x27;); $limit = $this-&gt;request-&gt;post(&#x27;limit&#x27;); $tol = ($page - 1) * $limit; $banner = BannerModel::where($where)-&gt;limit($tol, $limit)-&gt;select(); $count = BannerModel::where($where)-&gt;count(); if (!$banner) error(); success($banner, $count); &#125; return view(); 封装上传方法 一、打开项目在config文件夹下创建upload.php配置文件用来管理文件上传的后缀和大小 123456789101112131415161718&lt;?phpreturn [ //定义允许上传文件后缀的数组 &#x27;suffix_arr&#x27; =&gt; [ //允许图片上传的后缀 &#x27;image&#x27; =&gt; &#x27;jpg,jpeg,png,gif&#x27;, //允许上传文件的后缀 &#x27;file&#x27; =&gt; &#x27;zip,gz,doc,txt,pdf,xls&#x27;, //... ], //定义允许上传文件大小的数组 &#x27;size_arr&#x27; =&gt; [ //允许图片上传的大小 &#x27;image&#x27; =&gt; 10, //允许文件上传的大小 &#x27;file&#x27; =&gt; 50 ],]; 二、修改config\\filesystem.php配置文件配置上传根目录及上传规则 12345678910111213141516171819202122232425262728293031323334&lt;?phpreturn [ // 默认磁盘 &#x27;default&#x27; =&gt; &#x27;local&#x27;, // 磁盘列表 &#x27;disks&#x27; =&gt; [ &#x27;local&#x27; =&gt; [ &#x27;type&#x27; =&gt; &#x27;local&#x27;, &#x27;root&#x27; =&gt; app()-&gt;getRuntimePath() . &#x27;storage&#x27;, ], &#x27;public&#x27; =&gt; [ // 磁盘类型 &#x27;type&#x27; =&gt; &#x27;local&#x27;, // 磁盘路径 &#x27;root&#x27; =&gt; app()-&gt;getRootPath() . &#x27;public/storage&#x27;, // 磁盘路径对应的外部URL路径 &#x27;url&#x27; =&gt; &#x27;/storage&#x27;, // 可见性 &#x27;visibility&#x27; =&gt; &#x27;public&#x27;, ], // 更多的磁盘配置信息 &#x27;excel&#x27; =&gt; [ // 磁盘类型 &#x27;type&#x27; =&gt; &#x27;local&#x27;, // 磁盘路径 &#x27;root&#x27; =&gt; app()-&gt;getRootPath() . &#x27;public&#x27;, // 磁盘路径对应的外部URL路径 &#x27;url&#x27; =&gt; &#x27;/excel&#x27;, // 可见性 &#x27;visibility&#x27; =&gt; &#x27;public&#x27;, ], ],]; 在app\\controller目录下创建Upload.php类并编写upload()文件上传方法，如果是这样加个post请求判断 放在common方法里的话，可以直接调用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/** * 上传方法 * @param $file * @param string $name * @param string $type * @return bool|\\think\\response\\Json * * User: mi * Date: 2020-09-14 */ public function upload($file, $name = &#x27;file&#x27;, $type = &#x27;file&#x27;) &#123; //接收文件上传类型// $type = request()-&gt;param(&#x27;type&#x27;, &#x27;&#x27;, &#x27;trim&#x27;);// $name = request()-&gt;param(&#x27;name&#x27;, &#x27;&#x27;, &#x27;trim&#x27;);//// //获取表单上传文件// $file = request()-&gt;file(&#x27;file&#x27;); //组装文件保存目录 $upload_dir = &#x27;/&#x27; . $type . &#x27;/&#x27; . $name; try &#123; //从config/upload.php配置文件中读取允许上传的文件后缀和大小 $suffix_config = config(&#x27;upload.suffix_arr&#x27;); $size_config = config(&#x27;upload.size_arr&#x27;); if (empty($size_config[$type]) || empty($size_config[$type])) &#123; return false; &#125; else &#123; $suffix = $suffix_config[$type]; $size = $size_config[$type]; &#125; //验证器验证上传的文件 validate([&#x27;file&#x27; =&gt; [ //限制文件大小 &#x27;fileSize&#x27; =&gt; $size * 1024 * 1024, //限制文件后缀 &#x27;fileExt&#x27; =&gt; $suffix ]], [ &#x27;file.fileSize&#x27; =&gt; &#x27;上传的文件大小不能超过&#x27; . $size . &#x27;M&#x27;, &#x27;file.fileExt&#x27; =&gt; &#x27;请上传后缀为:&#x27; . $suffix . &#x27;的文件&#x27; ])-&gt;check([&#x27;file&#x27; =&gt; $file]); //上传文件到本地服务器 $filename = \\think\\facade\\Filesystem::disk(&#x27;public&#x27;)-&gt;putFile($upload_dir, $file); if ($filename) &#123; $src = &#x27;/storage/&#x27; . $filename;// return json([&#x27;code&#x27; =&gt; 1, &#x27;result&#x27; =&gt; $src]); return $src; &#125; else &#123; return json([&#x27;code&#x27; =&gt; 0, &#x27;msg&#x27; =&gt; &#x27;上传失败&#x27;]); &#125; &#125; catch (ValidateException $e) &#123; return json([&#x27;code&#x27; =&gt; 0, &#x27;msg&#x27; =&gt; $e-&gt;getMessage()]); &#125; &#125; 浏览器下载文件12345678910111213141516171819202122232425262728293031/** * 封装下载excel * User: mi * Date: 2020-10-12 */ public function head_upload($file_name) &#123; $file_name = iconv(&quot;utf-8&quot;, &quot;gbk//IGNORE&quot;, $file_name);; //中文表名转码 $file_dir = $_SERVER[&#x27;DOCUMENT_ROOT&#x27;].&quot;/excel_template/&quot;; //下载文件存放目录 //检查文件是否存在 if (!file_exists($file_dir . $file_name)) &#123; header(&#x27;HTTP/1.1 404 NOT FOUND&#x27;); &#125; else &#123; //以只读和二进制模式打开文件 $file = fopen($file_dir . $file_name, &quot;rb&quot;); //告诉浏览器这是一个文件流格式的文件 Header(&quot;Content-type: application/octet-stream&quot;); //请求范围的度量单位 Header(&quot;Accept-Ranges: bytes&quot;); //Content-Length是指定包含于请求或响应中数据的字节长度 Header(&quot;Accept-Length: &quot; . filesize($file_dir . $file_name)); //用来告诉浏览器，文件是可以当做附件被下载，下载后的文件名称为$file_name该变量的值。 Header(&quot;Content-Disposition: attachment; filename=&quot; . $file_name); //读取文件内容并直接输出到浏览器 echo fread($file, filesize($file_dir . $file_name)); fclose($file); exit (); &#125; &#125; tp时间操作php字符串类型时间转为秒数123$len = &quot;00:05:10.11&quot;; $time = date_parse($len); $seconds = $time[&#x27;hour&#x27;] * 3600 + $time[&#x27;minute&#x27;] * 60 + $time[&#x27;second&#x27;]; 判断两天是否是同一天12345678//判断两天是否是同一天function isDiffDays($last_date, $this_date)&#123; if (($last_date[&#x27;year&#x27;] === $this_date[&#x27;year&#x27;]) &amp;&amp; ($this_date[&#x27;yday&#x27;] === $last_date[&#x27;yday&#x27;])) &#123; return true; &#125; else &#123; return false; &#125; 传入时间计算距离现在第几周 未区分星期一，直接计算 123456789101112// 传入开学时间计算第几周public function current_week($time_chuo_of_first_day = &#x27;&#x27;)&#123; //今天的时间戳 $month = date(&#x27;n&#x27;); //获取月 n $day = date(&#x27;d&#x27;); //获取日 d $year = date(&#x27;Y&#x27;); //获取年 Y $time_chuo_of_current_day = mktime(0, 0, 0, $month, $day, $year); $cha = ($time_chuo_of_current_day - $time_chuo_of_first_day) / 60 / 60 / 24; $zhou = (int)(($cha+1) / 7 + 1); return $zhou;&#125; 传入周，计算周一的日期 12345678// 计算周一的时间public function mon($date)&#123; $now = strtotime($date); //当时的时间戳 $number = date(&quot;w&quot;,$now); //当时是周几 $number = $number == 0 ? 7 : $number; //如遇周末,将0换成7 $diff_day = $number - 1; //求到周一差几天 return date(&quot;Y-m-d&quot;,$now - ($diff_day * 60 * 60 * 24));&#125; 数据库操作——查询tp5查询用逗号分开的字段12$log_article = LogArticle::where(&#x27;find_in_set(:id,tag_ids)&#x27;,[&#x27;id&#x27;=&gt; input(&#x27;tag_id&#x27;)]) -&gt;select(); 页数1$tol = ($page-1) *$limit; 关键字搜索123if ($keys != &#x27;&#x27;) &#123; $where[] = [&#x27;title&#x27;,&#x27;like&#x27;,&#x27;%&#x27;.$keys.&#x27;%&#x27;]; &#125; 数据库操作——插入分组插入数据库 insert_data是需要插入的数据 123456$num = 100;$limit = ceil(count($insert_data)/$num);for ($i = 1; $i &lt;= $limit; $i++)&#123; $offset = ($i-1)*$num; $data = array_slice($insert_data, $offset, $num);&#125; 数据库其它操作事务123456789101112131415161718// 启动事务Db::startTrans();try &#123; Db::table(&#x27;think_user&#x27;)-&gt;find(1); Db::table(&#x27;think_user&#x27;)-&gt;delete(1); throw new Exception(&#x27;添加商品规格失败&#x27;, 1); // 提交事务 Db::commit();&#125; catch (\\Exception $e) &#123; $code = $e-&gt;getCode(); if ($code == 0)&#123; retMsg(0, $e-&gt;getMessage()); &#125;else&#123; retMsg(0, &#x27;网络繁忙，请稍后再试~&#x27;,[&#x27;error&#x27; =&gt; $e-&gt;getMessage()]); &#125; // 回滚事务 Db::rollback();&#125; 模型模型中无限分类 这是lemocms中的，但是都通用，传入的$cate需要分类的数组 123456789101112131415161718192021/** * 无限分类-权限 * @param $cate 栏目 * @param string $lefthtml 分隔符 * @param int $pid 父ID * @param int $lvl 层级 * @return array */ public static function cateTree($cate , $lefthtml = &#x27;|— &#x27; , $pid = 0 , $level = 0 )&#123; $arr = array(); foreach ($cate as $v)&#123; if ($v[&#x27;pid&#x27;] == $pid) &#123; $v[&#x27;level&#x27;] = $level + 1; $v[&#x27;lefthtml&#x27;] = str_repeat($lefthtml,$level); $v[&#x27;ltitle&#x27;] = $v[&#x27;lefthtml&#x27;].$v[&#x27;title&#x27;]; $arr[] = $v; $arr = array_merge($arr, self::cateTree($cate, $lefthtml, $v[&#x27;id&#x27;], $level+1)); &#125; &#125; return $arr; &#125; Base函数index基础函数 可以仿照为base，其他根据需求更改 12345678910111213141516171819202122232425public function index() &#123; if (Request::isPost()) &#123; // 关键词查询 $keys = $this-&gt;request-&gt;post(&#x27;keys&#x27;, &#x27;&#x27;, &#x27;trim&#x27;); $where = []; if ($keys != &#x27;&#x27;) &#123; $where[] = [&#x27;title&#x27;, &#x27;like&#x27;, &#x27;%&#x27; . $keys . &#x27;%&#x27;]; &#125; // 分页 $page = $this-&gt;request-&gt;post(&#x27;page&#x27;); $limit = $this-&gt;request-&gt;post(&#x27;limit&#x27;); $tol = ($page - 1) * $limit; // 查询需要展示的数据 $banner = BannerModel::where($where)-&gt;limit($tol, $limit)-&gt;select(); $count = BannerModel::where($where)-&gt;count(); if (!$banner) $this-&gt;errorMsg(); $this-&gt;successMsg($banner, $count); &#125; return view(); &#125; 配置伪静态apache配置 从官网下载的index.php后面没有 ? 因此这个和官网的区别在于index.php后面的 ? 12345678&lt;IfModule mod_rewrite.c&gt; Options +FollowSymlinks -Multiviews RewriteEngine On RewriteCond %&#123;REQUEST_FILENAME&#125; !-d RewriteCond %&#123;REQUEST_FILENAME&#125; !-f RewriteRule ^(.*)$ index.php?/$1 [QSA,PT,L]&lt;/IfModule&gt; 设置目录浏览在conf下找到vhosts.conf文件或者vhosts目录里，localhost配置下Options一行加上indexes即 Nginx配置12345678910if (!-d $request_filename)&#123; set $rule_0 1$rule_0;&#125;if (!-f $request_filename)&#123; set $rule_0 2$rule_0;&#125;if ($rule_0 = &quot;21&quot;)&#123; rewrite ^/(.*)$ /index.php?s=/$1 last;&#125; 上传，导出，下载上传excel，并且将其数据插入数据库 php上传excel需要用到PHPExcel 需要composer安装：composer require phpoffice/phpexcel（该方法最好实时从网上寻找，此不一定管用，以实际为准） composer安装完成在方法中使用 12use PHPExcel_IOFactory;use PHPExcel; tp中使用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788// excel上传 public function excel_upload()&#123; Db::startTrans(); try &#123; $file = $_FILES[&#x27;file&#x27;]; //需要用这种方法接收 $extension = strtolower(pathinfo($file[&#x27;name&#x27;], PATHINFO_EXTENSION)); //pathinfo()函数以数组的形式返回文件路径的信息 if ($extension == &quot;xlsx&quot;) &#123; //2007(相当于是打开接收的这个excel) $objReader = \\PHPExcel_IOFactory::createReader(&#x27;Excel2007&#x27;); &#125; else &#123; //2003(相当于是打开接收的这个excel) exit(json_encode([&#x27;status&#x27; =&gt; 0, &#x27;msg&#x27; =&gt; &#x27;不是期望的文件&#x27;])); &#125; // 这是另外一种，把表数据分为ABCD等来区分 //载入文件 $PHPExcel = $objReader-&gt;load($file[&#x27;tmp_name&#x27;]); //获取表中的第一个工作表，如果要获取第二个，把0改为1，依次类推 $currentSheet = $PHPExcel-&gt;getSheet(0); //获取总列数 $allColumn = $currentSheet-&gt;getHighestColumn(); //获取总行数 $allRow = $currentSheet-&gt;getHighestRow(); //循环获取表中的数据，$currentRow表示当前行，从哪行开始读取数据，索引值从0开始 for ($currentRow = 1; $currentRow &lt;= $allRow; $currentRow++) &#123; //从哪列开始，A表示第一列 for ($currentColumn = &#x27;A&#x27;; $currentColumn &lt;= $allColumn; $currentColumn++) &#123; //数据坐标 $address = $currentColumn . $currentRow; //读取到的数据，保存到数组$data中 $cell = $currentSheet-&gt;getCell($address)-&gt;getValue(); $data[$currentRow - 1][$currentColumn] = $cell; &#125; &#125; // 这是第一种，就是简单的 $objContent = $objReader-&gt;load($file[&#x27;tmp_name&#x27;]); //加载缓存文件 $sheetContent = $objContent-&gt;getSheet(0) //获取活动的表格 -&gt;toArray(); // 转换成数组 $excel_array = $sheetContent[0]; array_shift($sheetContent); $data = []; // 表格数据转为数组，而且该数组格式固定 foreach ($sheetContent as $k =&gt; $v)&#123; $data[$k][&#x27;supplier_name&#x27;] = $v[0]; $data[$k][&#x27;goods_code&#x27;] = $v[1]; $data[$k][&#x27;goods_name&#x27;] = $v[2]; $data[$k][&#x27;color&#x27;] = $v[3]; $data[$k][&#x27;color_code&#x27;] = $v[4]; $data[$k][&#x27;size_code&#x27;] = $v[5]; $data[$k][&#x27;size_name&#x27;] = $v[6]; $data[$k][&#x27;barcode&#x27;] = $v[7]; $data[$k][&#x27;inventory&#x27;] = $v[8]; // 这是判断店铺 if (count($v) &gt; 9)&#123; $shops_id = &#x27;&#x27;; $num = &#x27;&#x27;; for ($i = 1; $i &lt;= count($v)-9 ; $i++)&#123; // 判断是否在该店有库存 if ($v[8+$i] != null)&#123; $shops = Shops::where([&#x27;name&#x27; =&gt; $excel_array[8+$i]])-&gt;find(); if (!$shops) throw new Exception(&#x27;没有该店铺&#x27;.$excel_array[8+$i].&#x27;，请在后台添加&#x27;, 1); $shops_id = $shops[&#x27;id&#x27;].&#x27;,&#x27;.$shops_id; $num = $v[8+$i].&#x27;,&#x27;.$num; &#125; &#125; $shops_ids = substr($shops_id,0, strlen($shops_id)-1); $nums = substr($num,0, strlen($num)-1); $data[$k][&#x27;num&#x27;] = $nums; $data[$k][&#x27;shop_id&#x27;] = $shops_ids; &#125; &#125; Db::commit(); success(); &#125; catch (Exception $e) &#123; Db::rollback(); error($e-&gt;getMessage()); &#125; &#125; PHPExcel插入数据库内存溢出解决方案 修改本方法的配置文件，此属下策方案 方法1、扩大php默认分配内存 12ini_set(&quot;memory_limit&quot;, &quot;13312M&quot;);set_time_limit(0); 导出为excel $fileName = ‘表名’，$headArr = [‘关键词’, ‘出现次数’]（对应excel的表头）; 12345678$data = [ [ &#x27;数据1&#x27;, &#x27;数据 2&#x27; ], [ &#x27;数据1&#x27;, &#x27;数据2&#x27; ]]; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/** * 导出词云表 * User: mi * Date: 2020-09-29 */public function chu_ci_list()&#123; $fileName = &#x27;词云图统计表&#x27;; $headArr = [&#x27;关键词&#x27;, &#x27;出现次数&#x27;]; $ci_list = Cache::get(&#x27;ci_list&#x27;); $ci_data = unserialize($ci_list); $data = array(); $i = 0; foreach ($ci_data as $k =&gt; $item)&#123; $data[$i][0] = $k; $data[$i][1] = $item; $i++; &#125; $fileName .= &quot;-&quot; . date(&quot;YmdHi&quot;, time()) . &quot;.xlsx&quot;; $objPHPExcel = new \\PHPExcel(); $objPHPExcel-&gt;getProperties(); $key = ord(&quot;A&quot;); // 设置表头 foreach ($headArr as $v) &#123; $colum = chr($key); $objPHPExcel-&gt;setActiveSheetIndex(0)-&gt;setCellValue($colum . &#x27;1&#x27;, $v); $objPHPExcel-&gt;setActiveSheetIndex(0)-&gt;setCellValue($colum . &#x27;1&#x27;, $v); $key += 1; &#125; $column = 2; $objActSheet = $objPHPExcel-&gt;getActiveSheet(); foreach ($data as $key =&gt; $rows) &#123; // 行写入 $span = ord(&quot;A&quot;); foreach ($rows as $keyName =&gt; $value) &#123; // 列写入 $objActSheet-&gt;setCellValue(chr($span) . $column, $value); $span++; &#125; $column++; &#125; $fileName = iconv(&quot;utf-8&quot;, &quot;gb2312&quot;, $fileName); // 重命名表 $objPHPExcel-&gt;setActiveSheetIndex(0); // 设置活动单指数到第一个表,所以Excel打开这是第一个表 header(&#x27;Content-Type: application/vnd.ms-excel&#x27;); header(&quot;Content-Disposition: attachment;filename=$fileName&quot;); header(&#x27;Cache-Control: max-age=0&#x27;); $objWriter = \\PHPExcel_IOFactory::createWriter($objPHPExcel, &#x27;Excel5&#x27;); $objWriter-&gt;save(&#x27;php://output&#x27;); // 文件通过浏览器下载 exit();&#125; 字符串，数组操作提取字符串中的数字12345678910111213141516// 取出字符串中的数字 public function findNum($str = &#x27;&#x27;) &#123; $str = trim($str); if (empty($str)) &#123; return &#x27;&#x27;; &#125; $result = &#x27;&#x27;; for ($i = 0; $i &lt; strlen($str); $i++) &#123; if (is_numeric($str[$i])) &#123; $result .= $str[$i]; &#125; &#125; return $result; &#125; php实现数组按指定KEY排序的方法1234567891011121314151617// php实现数组按指定KEY排序的方法 public function array_sort($arr,$keys,$orderby=&#x27;asc&#x27;)&#123; $keysvalue = $new_array = array(); foreach ($arr as $k=&gt;$v)&#123; $keysvalue[$k] = $v[$keys]; &#125; if($orderby== &#x27;asc&#x27;)&#123; asort($keysvalue); &#125;else&#123; arsort($keysvalue); &#125; reset($keysvalue); foreach ($keysvalue as $k=&gt;$v)&#123; $new_array[] = $arr[$k]; &#125; return $new_array; &#125; 打印日志1file_put_contents(&#x27;ss.txt&#x27;,&#x27;data:--&gt;&#x27;.&#x27;0&#x27;.PHP_EOL,FILE_APPEND); phpPHP采用超长(超大)数字运算防止数字以科学计数法显示的方法12345678910111213141516171819202122232425262728293031323334353637383940414243function calc($m,$n,$x)&#123; $errors=array( &#x27;被除数不能为零&#x27;, &#x27;负数没有平方根&#x27; ); switch($x)&#123; case &#x27;add&#x27;: $t=bcadd($m,$n); break; case &#x27;sub&#x27;: $t=bcsub($m,$n); break; case &#x27;mul&#x27;: $t=bcmul($m,$n); break; case &#x27;div&#x27;: if($n!=0)&#123; $t=bcdiv($m,$n); &#125;else&#123; return $errors[0]; &#125; break; case &#x27;pow&#x27;: $t=bcpow($m,$n); break; case &#x27;mod&#x27;: if($n!=0)&#123; $t=bcmod($m,$n); &#125;else&#123; return $errors[0]; &#125; break; case &#x27;sqrt&#x27;: if($m&gt;=0)&#123; $t=bcsqrt($m); &#125;else&#123; return $errors[1]; &#125; break; &#125; $t=preg_replace(&quot;/\\..*0+$/&quot;,&#x27;&#x27;,$t); return $t;&#125; 截取后缀名1$postfix = trim(strrchr($file_name, &#x27;.&#x27;),&#x27;&#x27;); 将反斜杠转成正斜杠1$path = str_replace(&quot;\\\\&quot;,&#x27;/&#x27;,$info-&gt;getSaveName()); //将反斜杆转为正斜杠 应用公共返回方法123456789101112131415161718192021222324252627282930313233343536373839function success($data = [], $count = 0)&#123; header(&quot;Access-Control-Allow-Origin:*&quot;); header(&#x27;Access-Control-Allow-Methods:POST,GET&#x27;); header(&#x27;Content-Type:application/json&#x27;); $list[&#x27;code&#x27;] = 1; $list[&#x27;msg&#x27;] = &#x27;操作成功&#x27;; $list[&#x27;data&#x27;] = $data; $list[&#x27;count&#x27;] = $count; echo json_encode($list); die;&#125;function error($msg = &#x27;error&#x27;)&#123; header(&quot;Access-Control-Allow-Origin:*&quot;); header(&#x27;Access-Control-Allow-Methods:POST,GET&#x27;); header(&#x27;Content-Type:application/json&#x27;); $list[&#x27;code&#x27;] = 0; $list[&#x27;msg&#x27;] = $msg; echo json_encode($list); die;&#125;function retMsg($code = 0,$msg = &#x27;&#x27;, $data = [], $count = 0)&#123; header(&quot;Access-Control-Allow-Origin:*&quot;); header(&#x27;Access-Control-Allow-Methods:POST,GET&#x27;); header(&#x27;Content-Type:application/json&#x27;); $list[&#x27;code&#x27;] = $code; $list[&#x27;msg&#x27;] = $msg; $list[&#x27;data&#x27;] = $data; $list[&#x27;count&#x27;] = $count; echo json_encode($list); die;&#125; 封装概率123456789101112131415161718192021222324252627/** * 封装概率 * 作者：糜家智 * 时间：2021/4/29 17:19 */ public function get_rand($proArr) &#123; $result = array(); foreach ($proArr as $key =&gt; $val) &#123; $arr[$key] = $val[&#x27;v&#x27;]; // probability中奖概率 &#125; // 概率数组的总概率 $proSum = array_sum($arr); asort($arr); // 概率数组循环 foreach ($arr as $k =&gt; $v) &#123; $randNum = mt_rand(1, $proSum); if ($randNum &lt;= $v) &#123; $result = $proArr[$k]; break; &#125; else &#123; $proSum -= $v; &#125; &#125; return $result; &#125;","categories":[{"name":"thinkphp","slug":"thinkphp","permalink":"https://miren521.gihub.io/categories/thinkphp/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://miren521.gihub.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"分享","slug":"分享","permalink":"https://miren521.gihub.io/tags/%E5%88%86%E4%BA%AB/"}]},{"title":"Yapi使用教程","slug":"Yapi/Yapi使用教程","date":"2020-09-21T02:03:14.000Z","updated":"2021-07-10T12:13:04.789Z","comments":true,"path":"ckycsfmlg0003m0wfcgw369ph/","link":"","permalink":"https://miren521.gihub.io/ckycsfmlg0003m0wfcgw369ph/","excerpt":"YApi 是高效、易用、功能强大的 api 管理平台，旨在为开发、产品、测试人员提供更优雅的接口管理服务。可以帮助开发者轻松创建、发布、维护 API，YApi 还为用户提供了优秀的交互体验，开发人员只需利用平台提供的接口数据写入工具以及简单的点击操作就可以实现接口的管理。","text":"YApi 是高效、易用、功能强大的 api 管理平台，旨在为开发、产品、测试人员提供更优雅的接口管理服务。可以帮助开发者轻松创建、发布、维护 API，YApi 还为用户提供了优秀的交互体验，开发人员只需利用平台提供的接口数据写入工具以及简单的点击操作就可以实现接口的管理。 Yapi使用教程后端人员开发 登录网站，登录或注册：http://yapi.demo.qunar.com/（这yapi自己的服务，如果要用自己服务器的服务，需要自己搭建一套yapi工程，网易云课堂有相关课程） 登录成功后，可以创建对应项目 创建对应模块 添加模块下对应接口或修改模块名称 接口分类：可以选择对应模块 接口名称：对应接口的名称，如：绩查询 接口路径：为前端调用后端的接口路径，如：query12.do；也可以选择请求方式，如GET或POST 编写接口请求参数及返回值 编写接口成功后，可以页面运行，配置相关环境 运行后结果 对接口的导入导出 成员的加入管理，可以对加入开发的成员进行管理 前端人员开发 同上，通过组长对成员管理进行加入 tag标签的编辑，添加，自定义，谁接的接口，通过标签区分，以及错误区分","categories":[{"name":"Yapi","slug":"Yapi","permalink":"https://miren521.gihub.io/categories/Yapi/"}],"tags":[{"name":"后端","slug":"后端","permalink":"https://miren521.gihub.io/tags/%E5%90%8E%E7%AB%AF/"},{"name":"前端","slug":"前端","permalink":"https://miren521.gihub.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"接口开发","slug":"接口开发","permalink":"https://miren521.gihub.io/tags/%E6%8E%A5%E5%8F%A3%E5%BC%80%E5%8F%91/"}]},{"title":"心路历程","slug":"生活/心路历程/心路历程1","date":"2020-07-28T12:05:14.000Z","updated":"2021-07-10T12:13:04.820Z","comments":true,"path":"ckycsfmlo000bm0wfcietfl2x/","link":"","permalink":"https://miren521.gihub.io/ckycsfmlo000bm0wfcietfl2x/","excerpt":"心路历程，不变初心。","text":"心路历程，不变初心。 查看关于我","categories":[{"name":"生活","slug":"生活","permalink":"https://miren521.gihub.io/categories/%E7%94%9F%E6%B4%BB/"},{"name":"心路历程","slug":"生活/心路历程","permalink":"https://miren521.gihub.io/categories/%E7%94%9F%E6%B4%BB/%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/"}],"tags":[{"name":"感悟","slug":"感悟","permalink":"https://miren521.gihub.io/tags/%E6%84%9F%E6%82%9F/"}]},{"title":"layui点击图片预览","slug":"前端/layui/js/layui 点击图片预览","date":"2020-07-27T10:29:14.000Z","updated":"2021-07-10T12:13:04.806Z","comments":true,"path":"ckycsfmlu000mm0wf7q16eshp/","link":"","permalink":"https://miren521.gihub.io/ckycsfmlu000mm0wf7q16eshp/","excerpt":"表格中点击图片,预览","text":"表格中点击图片,预览 123456789101112131415161718192021function previewImg(obj) &#123; var img = new Image(); img.src = obj.src; var height = img.height + 50; //获取图片高度 var width = img.width; //获取图片宽度 var imgHtml = &quot;&lt;img src=&#x27;&quot; + obj.src + &quot;&#x27; /&gt;&quot;; //弹出层 layer.open(&#123; type: 1, shade: 0.8, offset: &#x27;auto&#x27;, area: [width + &#x27;px&#x27;,height+&#x27;px&#x27;], shadeClose:true,//点击外围关闭弹窗 scrollbar: false,//不现实滚动条 title: &quot;图片预览&quot;, //不显示标题 content: imgHtml, //捕获的元素，注意：最好该指定的元素要存放在body最外层，否则可能被其它的相对元素所影响 cancel: function () &#123; //layer.msg(&#x27;捕获就是从页面已经存在的元素上，包裹layer的结构&#x27;, &#123; time: 5000, icon: 6 &#125;); &#125; &#125;); &#125;","categories":[{"name":"layui","slug":"layui","permalink":"https://miren521.gihub.io/categories/layui/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://miren521.gihub.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"开发","slug":"开发","permalink":"https://miren521.gihub.io/tags/%E5%BC%80%E5%8F%91/"},{"name":"layui","slug":"layui","permalink":"https://miren521.gihub.io/tags/layui/"},{"name":"javascript","slug":"javascript","permalink":"https://miren521.gihub.io/tags/javascript/"}]},{"title":"layui关闭弹窗层并刷新父窗口","slug":"前端/layui/js/layui关闭弹窗层并刷新父窗口","date":"2020-07-27T10:28:14.000Z","updated":"2021-07-10T12:13:04.808Z","comments":true,"path":"ckycsfmlt000km0wfdeerc2al/","link":"","permalink":"https://miren521.gihub.io/ckycsfmlt000km0wfdeerc2al/","excerpt":"适用于打开弹窗编辑,添加数据等操作,且操作完成后,关闭弹窗并刷新父级","text":"适用于打开弹窗编辑,添加数据等操作,且操作完成后,关闭弹窗并刷新父级 123456789$(function() &#123;//关闭弹窗 $(document).on(&#x27;click&#x27;, &#x27;#closeBtn&#x27;, function() &#123; var index = parent.layer.getFrameIndex(window.name); //先得到当前iframe层的索引 parent.location.reload();//刷新父页面，注意一定要在关闭当前iframe层之前执行刷新 parent.layer.close(index); //再执行关闭 &#125;);&#125;);","categories":[{"name":"layui","slug":"layui","permalink":"https://miren521.gihub.io/categories/layui/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://miren521.gihub.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"开发","slug":"开发","permalink":"https://miren521.gihub.io/tags/%E5%BC%80%E5%8F%91/"},{"name":"layui","slug":"layui","permalink":"https://miren521.gihub.io/tags/layui/"},{"name":"javascript","slug":"javascript","permalink":"https://miren521.gihub.io/tags/javascript/"}]},{"title":"人生苦短，你一定要成为你自已想成为的那个人","slug":"生活/程序人生/人生苦短，你一定要成为你自已想成为的那个人","date":"2020-07-27T02:03:14.000Z","updated":"2021-07-10T12:13:04.822Z","comments":true,"path":"ckycsfmlq000fm0wfdogq4mni/","link":"","permalink":"https://miren521.gihub.io/ckycsfmlq000fm0wfdogq4mni/","excerpt":"何为成功和幸福？我们若活成了我们自己想成为的那个人，就是一个成功的人，就是一个幸福的人。保持一颗清净平和的心，勇敢坚强地生活。","text":"何为成功和幸福？我们若活成了我们自己想成为的那个人，就是一个成功的人，就是一个幸福的人。保持一颗清净平和的心，勇敢坚强地生活。 《金刚狼3》中有句台词：成为你自己想成为的你，别成为他们所希望的。最扎心的是真话。日子过得不好，别人不会替你背锅，每个成年人都要对自己的生命负责。比起人云亦云的尴尬，有主见的人敢于坚持自己喜欢的东西，活得通透豁达、不卑不亢，人生才会直线开挂。 或许，当你明确自己想要何种生活，当你知晓要和怎样的人共度余生，再去寻寻觅觅也不迟。 人生苦短，我们一定要成为我们自己想成的那个人。只有这样，在我们人生将要终结的时候，才可以带着满足和欣慰的目光离开，才可以不带任何遗憾的对所有来看我们的人说： “我度过了幸福的一生。” 成为自己想成为的人，不要成为别人想让你成为的人。这个世界其实最难做的事情就是活出自己，但是只要你愿意，你就可以活出自己。做自己喜欢的事情，不被别人打扰。 爱自己的生活，爱自己的一切。所有你能想到的，你想不到的都可以实现。只要你认真的去做，对待一切事情都把它当成自己的事情去做。这样你会收获不一样的精彩。 人一辈子只有一次，你要么成为你自己，要么你随波逐流，全看自己的选择。 在成为自己的这条道路上艰难而曲折，但是为了理想依然得必须面对。 理想是最不可辜负的，梦想的阀门一旦开启，注定无法停止。只要去坚持，你就可以收获。没有任何一条路是简单的，任何一条路都是困难重重。 重要的是你要坚持，这个过程无论遇到任何困难，你都要学会独立面对。成长本身就是疼痛的，舒服是留给死人的。 积极乐观的对待身边的人事物，将事情内化，而不是仅仅看表面。为了理想去付出，这个过程本身就是快乐的。 积极乐观的心态是良药。 乐观的心态容易让你获得快乐和自由，唯有乐观的状态才能真正的得到有价值的事情。不要活成别人眼中的自己，要活成自己眼中的自己。认真的对待自己所做的事情，保持一颗乐观的心。 埋怨世界不如改变自己，良好的心理状态是我们成长的催化剂。让自己优秀最好的方法就是不断的提高自己。只有自己优秀了，那么优秀的人才会向你靠近。 你要时刻明白，你所做的一切都是有意义的。你并不是为了得到别人的肯定而活，而是为了活出自己，得到自己的肯定。 前路凶险，披荆斩棘，方可立于不败之地。强化自己，让自己发光发彩。任何时候，都要不断的充实自己。 积极的向前走，努力成就自我，给自己的未来画上一个完美的句号。 一个人一种活法，没有十全十美。沿途的风景再美，我们的心依然要守住。何时都不忘了自己，任何时候都要让自己清醒。保持一种让认真的状态，这样才能真正的发挥自己的长处。 捷径有很多，但是捷径也不一定能真的让你快乐。快乐的活法是超脱的活法，是一种无欲无求的活法。但是面对这个繁杂的世界，我们有几个人能真的做到这种活法呢？ 我们心中拥有的只是利益，没有真正标准。我们该用我们的行动去证明我们自己。日复一日，周而复始。累了，困顿了，看清了，那么我们又该如何独善其身呢？相信自己的直觉和判断，努力经营自己，让自己成为一道光，去照亮别人，去温暖人心。相信自己，就一定可以做到。 最后，摘一片文章给大家： 成为你自己周国平 童年和少年是充满理想的美好时期。如果我问你们，你们将来想成为怎样的人，你们一定会给我许多漂亮的回答。譬如说，想成为拿破仑那样的伟人，爱因斯坦那样的大科学家，曹雪芹那样的文豪，等等。这些回答都不坏，不过，我认为比这一切都更重要的是：首先要成为你自己。 姑且假定你特别崇拜拿破仑，成为像他那样的盖世英雄是你最大的愿望。好吧，我问你：就让你成为拿破仑，生长在他那个时代，有他那些经历，你愿意吗？你很可能会激动得喊起来：太愿意啦！我再问你：让你从身体到灵魂整个儿都变成他，你也愿意吗？这下你或许有些犹豫了，会这么想：整个儿变成了他，不就是没有自己了吗？对了，我的朋友，正是这样。那么，你不愿意了？当然喽，因为这意味着世界上曾经有过拿破仑，这个事实没有改变，惟一的变化是你压根儿不存在了。 由此可见，对于每一个人来说，最宝贵的还是他自己。无论他多么羡慕别的什么人，如果让他彻头彻尾成为这个别人而不再是自己，谁都不肯了。 也许你会反驳我：你说的真是废话，每个人都已经是他自己了，怎么会彻头彻尾成为别人呢？不错，我只是在假设一种情形，这种情形不可能完全按照我所说的方式发生。不过，在实际生活中，类似情形却常常在以稍微不同的方式发生着。世上有许多人，你可以说他是随便什么东西，一种职业、一种身份、一个角色，或别的什么，惟独不是他自己。如果一个人总是按照别人的意见生活，没有自己的独立思考，总是为外在的事务忙碌，没有自己的内在生活，那么，说他不是他自己就一点没有冤枉他。因为确确实实，从他的头脑到他的心灵，你在其中已经找不到丝毫真正属于他自己的东西了，他只是别人的一个影子或事务的一架机器罢了。 那么，怎样才能成为自己呢？这是真正的难题，我承认我给不出答案。我还相信，不存在一个适用于一切人的答案。我只能说，最重要的是每个人都要真切地意识到他的“自我的宝贵”，有了这个觉悟，他就会自己去寻找属于他的答案。在茫茫宇宙间，每个人都只有一次生存的机会，都是一个独一无二、不可重复的存在。正像卢梭所说的，上帝把你造出来后，就把那个属于你的特定的模子打碎了。名声、财产、知识等等都是身外之物，人人都可求而得之，但你对人生的独特感受是没有人能够替代的。你死之后，没有人能够代替你再活一次。如果你真正意识到这一点，你就会明白，活在世上，最重要的就是活出你自己的特色和滋味来。你的人生是否有意义，衡量的标准不是外在的成功，而是你对积极人生的独特领悟和坚守。坚持这一标准，你的自我才能闪放出个性的光华。 在历史上，每当世风腐败之时，人们就会盼望救世主出现。其实，救世主就在每个人的心中。 ————————————————版权声明：本文为CSDN博主「东海陈光剑」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/universsky2015/article/details/106094620","categories":[{"name":"生活","slug":"生活","permalink":"https://miren521.gihub.io/categories/%E7%94%9F%E6%B4%BB/"},{"name":"程序人生","slug":"生活/程序人生","permalink":"https://miren521.gihub.io/categories/%E7%94%9F%E6%B4%BB/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"}],"tags":[{"name":"努力","slug":"努力","permalink":"https://miren521.gihub.io/tags/%E5%8A%AA%E5%8A%9B/"},{"name":"奋斗","slug":"奋斗","permalink":"https://miren521.gihub.io/tags/%E5%A5%8B%E6%96%97/"},{"name":"人生","slug":"人生","permalink":"https://miren521.gihub.io/tags/%E4%BA%BA%E7%94%9F/"}]},{"title":"php中session和cookie的使用","slug":"php/php面试/php中session和cookie的使用","date":"2020-07-12T17:28:23.000Z","updated":"2021-07-10T12:13:04.799Z","comments":true,"path":"ckycsfmln0009m0wf7oe9aubz/","link":"","permalink":"https://miren521.gihub.io/ckycsfmln0009m0wf7oe9aubz/","excerpt":"php中session和cookie的使用，平常项目开发中不可缺少的一部分","text":"php中session和cookie的使用，平常项目开发中不可缺少的一部分 php中session和cookie的使用及区别 cookie的使用 什么是cookiecookie 常用于识别用户。cookie 是服务器留在用户计算机中的小文件。每当相同的计算机通过浏览器请求页面时，它同时会发送 cookie。通过 PHP，您能够创建并取回 cookie 的值。 简述cookiePHP工作原理：PHP通过setcookie函数进行Cookie的设置，任何从浏览器发回的Cookie，PHP都会自动的将他存储在$_COOKIE的全局变量之中，因此我们可以通过$_COOKIE[‘key’]的形式来读取某个Cookie值。 用途：PHP中的Cookie具有非常广泛的使用，经常用来存储用户的登录信息，购物车等，且在使用会话 Session时通常使用Cookie来存储会话id来识别用户，Cookie具备有效期，当有效期结束之后，Cookie会自动的从客户端删除。同时为 了进行安全控制，Cookie还可以设置域跟路径。 删除cookiePHP设置Cookie最常用的方法就是使用setcookie函数，setcookie具有7个可选参数，我们常用到的为前5个： name（ Cookie名）可以通过$_COOKIE[‘name’] 进行访问 value（Cookie的值） expire（过期时间）Unix时间戳格式，默认为0，表示浏览器关闭即失效 path（有效路径）如果路径设置为’/‘，则整个网站都有效 domain（有效域）默认整个域名都有效，如果设置了’www.imooc.com&#39;,则只在www子域中有效 1$value` `= ``&#x27;test&#x27;``;``setcookie(``&quot;TestCookie&quot;``, ``$value``);``setcookie(``&quot;TestCookie&quot;``, ``$value``, time()+3600); ``//有效期一小时``setcookie(``&quot;TestCookie&quot;``, ``$value``, time()+3600, ``&quot;/path/&quot;``, ``&quot;imooc.com&quot;``); ``//设置路径与域 PHP中还有一个设置Cookie的函数setrawcookie，setrawcookie跟setcookie基本一样，唯一的不同就是value值不会自动的进行urlencode，因此在需要的时候要手动的进行urlencode。 1setrawcookie(``&#x27;cookie_name&#x27;``, rawurlencode(``$value``), time()+606024*365); 因为Cookie是通过HTTP标头进行设置的，所以也可以直接使用header方法进行设置。 1header(``&quot;Set-Cookie:cookie_name=value&quot;``); session的使用 session是啥？ &emsp;&emsp;首先，我大致的知道，session是一次浏览器和服务器的交互的会话，会话是啥呢？就是我问候你好吗？你回恩很好。就是一次会话，那么对话完成后，这次会话就结束了，还有我也知道，我们可以将一个变量存入全部的$_SESSION[‘name’]中，这样php的各个页面和逻辑都能访问到，所以很轻松的用来判断是否登陆。 &emsp;&emsp;这是我之前理解的session，当然也是对的，只是解释的太肤浅，理解的太表面了，面试官如果听到这样的答案其实是不太满意的。我参考了其他的很多资料，彻底理解清楚session。 &emsp;&emsp;在说session是啥之前，我们先来说说为什么会出现session会话，它出现的机理是什么？我们知道，我们用浏览器打开一个网页，用到的是HTTP协议，学过计算机的应该都知道这个协议，它是无状态的，什么是无状态呢？就是说这一次请求和上一次请求是没有任何关系的，互不认识的，没有关联的。但是这种无状态的的好处是快速。 &emsp;&emsp;所以就会带来一个问题就是，我希望几个请求的页面要有关联，比如：我在www.a.com/login.php里面登陆了，我在www.a.com/index.php 也希望是登陆状态，但是，这是2个不同的页面，也就是2个不同的HTTP请求，这2个HTTP请求是无状态的，也就是无关联的，所以无法单纯的在index.php中读取到它在login.php中已经登陆了！ &emsp;&emsp;那咋搞呢？我不可能这2个页面我都去登陆一遍吧。或者用笨方法这2个页面都去查询数据库，如果有登陆状态，就判断是登陆的了。这种查询数据库的方案虽然可行，但是每次都要去查询数据库不是个事，会造成数据库的压力。 &emsp;&emsp;所以正是这种诉求，这个时候，一个新的客户端存储数据方式出现了：cookie。cookie是把少量的信息存储在用户自己的电脑上，它在一个域名下是一个全局的，只要设置它的存储路径在域名www.a.com下 ，那么当用户用浏览器访问时，php就可以从这个域名的任意页面读取cookie中的信息。所以就很好的解决了我在www.a.com/login.php页面登陆了，我也可以在www.a.com/index.php获取到这个登陆信息了。同时又不用反复去查询数据库。 &emsp;&emsp;虽然这种方案很不错，也很快速方便，但是由于cookie 是存在用户端，而且它本身存储的尺寸大小也有限，最关键是用户可以是可见的，并可以随意的修改，很不安全。那如何又要安全，又可以方便的全局读取信息呢？于是，这个时候，一种新的存储会话机制：session 诞生了。 &emsp;&emsp;我擦，终于把session是怎么诞生的给圆清楚了，不容易啊！！！ &emsp;&emsp;好，session 诞生了，从上面的描述来讲，它就是在一次会话中解决2次HTTP的请求的关联，让它们产生联系，让2两个页面都能读取到找个这个全局的session信息。session信息存在于服务器端，所以也就很好的解决了安全问题。 session的运行机制和是怎么保存的？&emsp;&emsp;既然，它也是一种服务区存储数据的方式，肯定也是存在服务器的某个地方了。确实，它存在服务器的/tmp 目录下，这一点我们接下来慢慢讲。 &emsp;&emsp;我们先说下它的运行机制，是怎么分配的。我们主要用PHP中session的机制，其实各种语言都差不多。","categories":[{"name":"php","slug":"php","permalink":"https://miren521.gihub.io/categories/php/"}],"tags":[{"name":"php面试","slug":"php面试","permalink":"https://miren521.gihub.io/tags/php%E9%9D%A2%E8%AF%95/"},{"name":"开发","slug":"开发","permalink":"https://miren521.gihub.io/tags/%E5%BC%80%E5%8F%91/"}]},{"title":"学习使我快乐","slug":"学习使我快乐","date":"2020-07-09T02:03:14.000Z","updated":"2021-07-10T12:13:04.819Z","comments":true,"path":"ckycsfmld0001m0wf3gmg5yoe/","link":"","permalink":"https://miren521.gihub.io/ckycsfmld0001m0wf3gmg5yoe/","excerpt":"学习是一件值得努力的事情","text":"学习是一件值得努力的事情 如何让自己静下心来安静的学习 首先需要信念 其次需要目标","categories":[{"name":"学习","slug":"学习","permalink":"https://miren521.gihub.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"努力","slug":"努力","permalink":"https://miren521.gihub.io/tags/%E5%8A%AA%E5%8A%9B/"},{"name":"奋斗","slug":"奋斗","permalink":"https://miren521.gihub.io/tags/%E5%A5%8B%E6%96%97/"}]}],"categories":[{"name":"前端","slug":"前端","permalink":"https://miren521.gihub.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"uni-app","slug":"前端/uni-app","permalink":"https://miren521.gihub.io/categories/%E5%89%8D%E7%AB%AF/uni-app/"},{"name":"工具","slug":"工具","permalink":"https://miren521.gihub.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"基础","slug":"前端/基础","permalink":"https://miren521.gihub.io/categories/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/"},{"name":"面试","slug":"前端/面试","permalink":"https://miren521.gihub.io/categories/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95/"},{"name":"古怪","slug":"前端/古怪","permalink":"https://miren521.gihub.io/categories/%E5%89%8D%E7%AB%AF/%E5%8F%A4%E6%80%AA/"},{"name":"生活","slug":"生活","permalink":"https://miren521.gihub.io/categories/%E7%94%9F%E6%B4%BB/"},{"name":"必备软件","slug":"生活/必备软件","permalink":"https://miren521.gihub.io/categories/%E7%94%9F%E6%B4%BB/%E5%BF%85%E5%A4%87%E8%BD%AF%E4%BB%B6/"},{"name":"vue","slug":"前端/vue","permalink":"https://miren521.gihub.io/categories/%E5%89%8D%E7%AB%AF/vue/"},{"name":"thinkphp","slug":"thinkphp","permalink":"https://miren521.gihub.io/categories/thinkphp/"},{"name":"Yapi","slug":"Yapi","permalink":"https://miren521.gihub.io/categories/Yapi/"},{"name":"心路历程","slug":"生活/心路历程","permalink":"https://miren521.gihub.io/categories/%E7%94%9F%E6%B4%BB/%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/"},{"name":"layui","slug":"layui","permalink":"https://miren521.gihub.io/categories/layui/"},{"name":"程序人生","slug":"生活/程序人生","permalink":"https://miren521.gihub.io/categories/%E7%94%9F%E6%B4%BB/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"},{"name":"php","slug":"php","permalink":"https://miren521.gihub.io/categories/php/"},{"name":"学习","slug":"学习","permalink":"https://miren521.gihub.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://miren521.gihub.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"uni-app","slug":"uni-app","permalink":"https://miren521.gihub.io/tags/uni-app/"},{"name":"页面操作","slug":"页面操作","permalink":"https://miren521.gihub.io/tags/%E9%A1%B5%E9%9D%A2%E6%93%8D%E4%BD%9C/"},{"name":"效率开发","slug":"效率开发","permalink":"https://miren521.gihub.io/tags/%E6%95%88%E7%8E%87%E5%BC%80%E5%8F%91/"},{"name":"webstorm","slug":"webstorm","permalink":"https://miren521.gihub.io/tags/webstorm/"},{"name":"vscode","slug":"vscode","permalink":"https://miren521.gihub.io/tags/vscode/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://miren521.gihub.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"分享","slug":"分享","permalink":"https://miren521.gihub.io/tags/%E5%88%86%E4%BA%AB/"},{"name":"基础","slug":"基础","permalink":"https://miren521.gihub.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"js","slug":"js","permalink":"https://miren521.gihub.io/tags/js/"},{"name":"开发","slug":"开发","permalink":"https://miren521.gihub.io/tags/%E5%BC%80%E5%8F%91/"},{"name":"javascript","slug":"javascript","permalink":"https://miren521.gihub.io/tags/javascript/"},{"name":"古怪学习","slug":"古怪学习","permalink":"https://miren521.gihub.io/tags/%E5%8F%A4%E6%80%AA%E5%AD%A6%E4%B9%A0/"},{"name":"软件","slug":"软件","permalink":"https://miren521.gihub.io/tags/%E8%BD%AF%E4%BB%B6/"},{"name":"windows","slug":"windows","permalink":"https://miren521.gihub.io/tags/windows/"},{"name":"vue","slug":"vue","permalink":"https://miren521.gihub.io/tags/vue/"},{"name":"指南","slug":"指南","permalink":"https://miren521.gihub.io/tags/%E6%8C%87%E5%8D%97/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://miren521.gihub.io/tags/JavaScript/"},{"name":"HTML、HTTP","slug":"HTML、HTTP","permalink":"https://miren521.gihub.io/tags/HTML%E3%80%81HTTP/"},{"name":"后端","slug":"后端","permalink":"https://miren521.gihub.io/tags/%E5%90%8E%E7%AB%AF/"},{"name":"接口开发","slug":"接口开发","permalink":"https://miren521.gihub.io/tags/%E6%8E%A5%E5%8F%A3%E5%BC%80%E5%8F%91/"},{"name":"感悟","slug":"感悟","permalink":"https://miren521.gihub.io/tags/%E6%84%9F%E6%82%9F/"},{"name":"layui","slug":"layui","permalink":"https://miren521.gihub.io/tags/layui/"},{"name":"努力","slug":"努力","permalink":"https://miren521.gihub.io/tags/%E5%8A%AA%E5%8A%9B/"},{"name":"奋斗","slug":"奋斗","permalink":"https://miren521.gihub.io/tags/%E5%A5%8B%E6%96%97/"},{"name":"人生","slug":"人生","permalink":"https://miren521.gihub.io/tags/%E4%BA%BA%E7%94%9F/"},{"name":"php面试","slug":"php面试","permalink":"https://miren521.gihub.io/tags/php%E9%9D%A2%E8%AF%95/"}]}